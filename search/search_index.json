{"config":{"indexing":"full","lang":["en","ru"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"get_token/","text":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 API \u0442\u043e\u043a\u0435\u043d\u0430 \u0414\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f CryptoPay API \u0442\u043e\u043a\u0435\u043d\u0430, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u044c\u0441\u044f \u043a \u0431\u043e\u0442\u0443 @CryptoBot . \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438 \u0414\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0442\u043e\u043a\u0435\u043d\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438, \u043e\u0431\u0440\u0430\u0449\u0430\u0442\u044c\u0441\u044f \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u043a \u0431\u043e\u0442\u0443 @CryptoTestnetBot , \u0438 \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u044d\u0442\u043e\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438. \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0431\u043e\u0442\u0435 \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0431\u043e\u0442\u0430 \u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0431\u043e\u0442\u0430, \u0443\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c \u0447\u0442\u043e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0431\u043e\u0442\u0435 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0439 \u043d\u0438\u0436\u0435! \u0414\u043b\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0433\u043e \u0431\u043e\u0442\u0430 @CryptoBot : \u0414\u043b\u044f \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0431\u043e\u0442\u0430 @CryptoTestnetBot : \u0412\u0445\u043e\u0434 \u0432 \u0431\u043e\u0442\u0430 \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 /start \u0432 \u0431\u043e\u0442\u0435 \u0434\u043b\u044f \u0432\u044b\u0445\u043e\u0434\u0430 \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e \u0438 \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \ud83c\udfdd\ufe0f Crypto Pay \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 , CryptoBot \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u0441\u043e\u0437\u0434\u0430\u0441\u0442 \u0432\u0430\u043c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u043c \u0438\u043c\u0435\u043d\u0435\u043c. \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 API \u0442\u043e\u043a\u0435\u043d\u0430 \u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \"API-\u0442\u043e\u043a\u0435\u043d\" \u0447\u0442\u043e\u0431\u044b \u0443\u0432\u0438\u0434\u0435\u0442\u044c \u0441\u0432\u043e\u0439 API \u0442\u043e\u043a\u0435\u043d, \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u043e\u043d \u0438\u0437 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 000000:XXXXXXXXXXXXXXXXXXXXXXXXX \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u0430 \u041f\u043e\u043b\u0443\u0447\u0438\u0432 \u0442\u043e\u043a\u0435\u043d \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0435\u0433\u043e \u043f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u0438\u043d\u0441\u0442\u0430\u043d\u0441\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 CryptoPay \u0432\u043e\u0442 \u0442\u0430\u043a CryptoPay('000000:XXXXXXXXXXXXXXXXXXXXXXXXX') . \u0412\u043d\u0438\u043c\u0430\u043d\u0438\u0435 \u041d\u0435 \u0437\u0430\u0431\u0443\u0434\u044c\u0442\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0444\u043b\u0430\u0433 testnet=True \u0435\u0441\u043b\u0438 \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u0442\u043e\u043a\u0435\u043d \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0431\u043e\u0442\u0430, \u0438\u043d\u0430\u0447\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0435 \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u043e\u0439\u0434\u0435\u043d\u0430.","title":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 API \u0442\u043e\u043a\u0435\u043d\u0430"},{"location":"get_token/#api","text":"\u0414\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f CryptoPay API \u0442\u043e\u043a\u0435\u043d\u0430, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u044c\u0441\u044f \u043a \u0431\u043e\u0442\u0443 @CryptoBot . \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438 \u0414\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0442\u043e\u043a\u0435\u043d\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438, \u043e\u0431\u0440\u0430\u0449\u0430\u0442\u044c\u0441\u044f \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u043a \u0431\u043e\u0442\u0443 @CryptoTestnetBot , \u0438 \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u044d\u0442\u043e\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438.","title":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 API \u0442\u043e\u043a\u0435\u043d\u0430"},{"location":"get_token/#_1","text":"\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0431\u043e\u0442\u0430 \u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0431\u043e\u0442\u0430, \u0443\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c \u0447\u0442\u043e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0431\u043e\u0442\u0435 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0439 \u043d\u0438\u0436\u0435! \u0414\u043b\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0433\u043e \u0431\u043e\u0442\u0430 @CryptoBot : \u0414\u043b\u044f \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0431\u043e\u0442\u0430 @CryptoTestnetBot :","title":"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0431\u043e\u0442\u0435"},{"location":"get_token/#_2","text":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 /start \u0432 \u0431\u043e\u0442\u0435 \u0434\u043b\u044f \u0432\u044b\u0445\u043e\u0434\u0430 \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e \u0438 \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \ud83c\udfdd\ufe0f Crypto Pay","title":"\u0412\u0445\u043e\u0434 \u0432 \u0431\u043e\u0442\u0430"},{"location":"get_token/#_3","text":"\u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 , CryptoBot \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u0441\u043e\u0437\u0434\u0430\u0441\u0442 \u0432\u0430\u043c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u043c \u0438\u043c\u0435\u043d\u0435\u043c.","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f"},{"location":"get_token/#api_1","text":"\u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \"API-\u0442\u043e\u043a\u0435\u043d\" \u0447\u0442\u043e\u0431\u044b \u0443\u0432\u0438\u0434\u0435\u0442\u044c \u0441\u0432\u043e\u0439 API \u0442\u043e\u043a\u0435\u043d, \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u043e\u043d \u0438\u0437 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 000000:XXXXXXXXXXXXXXXXXXXXXXXXX","title":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 API \u0442\u043e\u043a\u0435\u043d\u0430"},{"location":"get_token/#_4","text":"\u041f\u043e\u043b\u0443\u0447\u0438\u0432 \u0442\u043e\u043a\u0435\u043d \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0435\u0433\u043e \u043f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u0438\u043d\u0441\u0442\u0430\u043d\u0441\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 CryptoPay \u0432\u043e\u0442 \u0442\u0430\u043a CryptoPay('000000:XXXXXXXXXXXXXXXXXXXXXXXXX') . \u0412\u043d\u0438\u043c\u0430\u043d\u0438\u0435 \u041d\u0435 \u0437\u0430\u0431\u0443\u0434\u044c\u0442\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0444\u043b\u0430\u0433 testnet=True \u0435\u0441\u043b\u0438 \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u0442\u043e\u043a\u0435\u043d \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0431\u043e\u0442\u0430, \u0438\u043d\u0430\u0447\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0435 \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u043e\u0439\u0434\u0435\u043d\u0430.","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u0430"},{"location":"","text":"\u0413\u043b\u0430\u0432\u043d\u0430\u044f Crypto Pay \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u043e\u043f\u043b\u0430\u0442\u044b \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 @CryptoBot , \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0432\u0430\u043c \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u043f\u043b\u0430\u0442\u0435\u0436\u0438 \u043a\u0440\u0438\u043f\u0442\u043e\u0432\u0430\u043b\u044e\u0442\u043e\u0439 \u0447\u0435\u0440\u0435\u0437 \u0438\u0445 API. \u042d\u0442\u0430 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u043f\u043e\u043c\u043e\u0436\u0435\u0442 \u0432\u0430\u043c \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u0441 Crypto Pay \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e Crypto Pay API \u0432 \u0432\u0430\u0448\u0438\u0445 Python \u0441\u043a\u0440\u0438\u043f\u0442\u0430\u0445. Documentation available on English language \u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430 \u043d\u0430 \u0420\u0443\u0441\u0441\u043a\u043e\u043c \u044f\u0437\u044b\u043a\u0435","title":"\u0413\u043b\u0430\u0432\u043d\u0430\u044f"},{"location":"#_1","text":"Crypto Pay \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u043e\u043f\u043b\u0430\u0442\u044b \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 @CryptoBot , \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0432\u0430\u043c \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u043f\u043b\u0430\u0442\u0435\u0436\u0438 \u043a\u0440\u0438\u043f\u0442\u043e\u0432\u0430\u043b\u044e\u0442\u043e\u0439 \u0447\u0435\u0440\u0435\u0437 \u0438\u0445 API. \u042d\u0442\u0430 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u043f\u043e\u043c\u043e\u0436\u0435\u0442 \u0432\u0430\u043c \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u0441 Crypto Pay \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e Crypto Pay API \u0432 \u0432\u0430\u0448\u0438\u0445 Python \u0441\u043a\u0440\u0438\u043f\u0442\u0430\u0445. Documentation available on English language \u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430 \u043d\u0430 \u0420\u0443\u0441\u0441\u043a\u043e\u043c \u044f\u0437\u044b\u043a\u0435","title":"\u0413\u043b\u0430\u0432\u043d\u0430\u044f"},{"location":"install/","text":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0411\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 \u043c\u043e\u0436\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u043c\u0438 \u0441\u043f\u043e\u0441\u043e\u0431\u0430\u043c\u0438: \u0427\u0435\u0440\u0435\u0437 PYPI \u0427\u0435\u0440\u0435\u0437 pip+git \u0418\u0437 \u0438\u0441\u0445\u043e\u0434\u043d\u0438\u043a\u043e\u0432 pip install pycryptopay-sdk pip install git+https://github.com/LulzLoL231/pyCryptoPayAPI.git pip install . # (1)! \u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u0432 \u043f\u0430\u043f\u043a\u0435 \u0441 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u043e\u0439","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430"},{"location":"install/#_1","text":"\u0411\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 \u043c\u043e\u0436\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u043c\u0438 \u0441\u043f\u043e\u0441\u043e\u0431\u0430\u043c\u0438: \u0427\u0435\u0440\u0435\u0437 PYPI \u0427\u0435\u0440\u0435\u0437 pip+git \u0418\u0437 \u0438\u0441\u0445\u043e\u0434\u043d\u0438\u043a\u043e\u0432 pip install pycryptopay-sdk pip install git+https://github.com/LulzLoL231/pyCryptoPayAPI.git pip install . # (1)! \u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u0432 \u043f\u0430\u043f\u043a\u0435 \u0441 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u043e\u0439","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430"},{"location":"API/CryptoPayAPI/errors/","text":"\u0418\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f","title":"\u0418\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f"},{"location":"API/CryptoPayAPI/errors/#_1","text":"","title":"\u0418\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f"},{"location":"API/CryptoPayAPI/","text":"\u041a\u043b\u0430\u0441\u0441 CryptoPay CryptoPay CryptoPay payment system. Source code in src/CryptoPayAPI/api.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class CryptoPay : '''CryptoPay payment system. ''' def __init__ ( self , api_key : str , testnet : bool = False ) -> None : ''' Args: api_key (str): CryptoPay API token. testnet (bool): Use Testnet? Defaults to False. ''' self . timeout_sec = 5 self . log = logging . getLogger ( 'CryptoPay' ) self . api_key = api_key self . headers = { 'Crypto-Pay-API-Token' : api_key } self . testnet = testnet if testnet : self . endpoint = TESTHOST else : self . endpoint = MAINHOST self . client = AsyncClient ( headers = self . headers , base_url = self . endpoint , timeout = Timeout ( self . timeout_sec ) ) async def _callApi ( self , http_method : str , api_method : str , query : dict = {}) -> dict : '''Makes a api call. Args: http_method (str): HTTP method. Available is \"GET\" and \"POST\". api_method (str): API method. query (dict, optional): Request query in dict. Defaults to {}. Returns: dict: API response as JSON dict viceversa None. ''' self . log . debug ( f 'Called with args ( { http_method } , { api_method } , { query } )' ) if query : params = urllib . parse . urlencode ( query ) else : params = None resp = await self . client . request ( http_method , api_method , params = params ) if resp . is_success : data = resp . json () self . log . debug ( f 'API answer: { data } ' ) if data [ 'ok' ]: return data [ 'result' ] else : raise UnexpectedError ( f '[ { data [ \"error\" ][ \"code\" ] } ] { data [ \"error\" ][ \"name\" ] } ' , data ) else : if resp . status_code == 401 : raise UnauthorizedError ( 'Token not found!' ) elif resp . status_code == 405 : raise MethodNotFoundError ( f 'Method { api_method } not found!' ) elif resp . status_code == 400 : data = resp . json () err = data [ 'error' ][ 'name' ] if err == 'EXPIRES_IN_INVALID' : raise ExpiresInInvalidError ( f 'Expires \" { query [ \"expires_in\" ] } \" is invalid!' , raw_response = data ) elif resp . status_code == 403 : data = resp . json () err = data [ 'error' ][ 'name' ] if err == 'METHOD_DISABLED' : raise MethodDisabledError ( f 'Method \" { api_method } \" is disabled!' , raw_response = data ) data = resp . json () raise UnexpectedError ( f '[ { data [ \"error\" ][ \"code\" ] } ] { data [ \"error\" ][ \"name\" ] } ' , raw_response = data ) async def get_me ( self ) -> schemas . Application : '''Returns basic information about an app. Returns: types.Application: Basic information about an app. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getMe' ) return schemas . Application ( ** result ) async def get_balance ( self ) -> List [ schemas . Balance ]: '''Use this method to get a balance of your app. Returns: List[types.Balance]: Array of assets. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getBalance' ) return [ schemas . Balance ( ** i ) for i in result ] async def get_exchange_rates ( self ) -> List [ schemas . ExchangeRate ]: '''Use this method to get exchange rates of supported currencies. Returns: List[types.ExchangeRate]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getExchangeRates' ) return [ schemas . ExchangeRate ( ** i ) for i in result ] async def get_currencies ( self ) -> List [ schemas . Currency ]: '''Use this method to get a list of supported currencies. Returns: List[types.Currency]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getCurrencies' ) return [ schemas . Currency ( ** i ) for i in result ] async def create_invoice ( self , asset : schemas . Assets , amount : float , description : Optional [ str ] = None , hidden_message : Optional [ str ] = None , paid_btn_name : Optional [ schemas . PaidButtonNames ] = None , paid_btn_url : Optional [ str ] = None , payload : Optional [ str ] = None , allow_comments : bool = True , allow_anonymous : bool = True , expires_in : Optional [ int ] = None ) -> schemas . Invoice : '''Create a new invoice. Args: asset (types.Assets): Currency. amount (float): Amount of invoice in float. description (Optional[str]): Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. hidden_message (Optional[str]): Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. paid_btn_name (Optional[types.PaidButtonNames]): Name of the button that will be shown to a user after the invoice is paid. Defaults to None. paid_btn_url (Optional[str]): Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. payload (Optional[str]): Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. allow_comments (bool): Allow a user to add a comment to the payment. Defaults to True. allow_anonymous (bool): Allow a user to pay the invoice anonymously. Defaults to True. expires_in (Optional[int]): You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. Returns: types.Invoice: Object of the created invoice. ''' self . log . debug ( f 'Called with args ( { asset } , { amount } , { description } , { hidden_message } , { paid_btn_name } , { paid_btn_url } , { payload } , { allow_comments } , { allow_anonymous } , { expires_in } )' ) params = { 'asset' : str ( asset ), 'amount' : amount , 'allow_comments' : allow_comments , 'allow_anonymous' : allow_anonymous } if description : params [ 'description' ] = description elif hidden_message : params [ 'hidden_message' ] = hidden_message elif paid_btn_name : params [ 'paid_btn_name' ] = str ( paid_btn_name ) params [ 'paid_btn_url' ] = paid_btn_url elif payload : params [ 'payload' ] = payload elif expires_in : params [ 'expires_in' ] = expires_in result = await self . _callApi ( 'POST' , 'createInvoice' , params ) return schemas . Invoice ( ** result ) async def get_invoices ( self , asset : Optional [ schemas . Assets ] = None , invoice_ids : Optional [ str ] = None , status : Optional [ schemas . InvoiceStatus ] = None , offset : int = 0 , count : int = 100 ) -> List [ schemas . Invoice ]: '''Use this method to get invoices of your app. Args: asset (Optional[types.Assets]): Currency codes separated by comma. Defaults to all assets. invoice_ids (Optional[str]): Invoice IDs separated by comma. Defaults to None. status (Optional[types.InvoiceStatus]): Status of invoices to be returned. Defaults to all statuses. offset (int): Offset needed to return a specific subset of invoices. Defaults to 0. count (int): Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. Returns: List[types.Invoice]: Array of invoices. ''' self . log . debug ( f 'Called with args ( { asset } , { invoice_ids } , { status } , { offset } , { count } )' ) params : Dict [ str , Union [ str , int ]] = { 'offset' : offset , 'count' : count } if asset : params [ 'asset' ] = str ( asset ) elif invoice_ids : params [ 'invoice_ids' ] = invoice_ids elif status : params [ 'status' ] = str ( status ) result = await self . _callApi ( 'GET' , 'getInvoices' , params ) return [ schemas . Invoice ( ** i ) for i in result [ 'items' ]] async def transfer ( self , user_id : int , asset : schemas . Assets , amount : float , spend_id : str , comment : Optional [ str ] = None , disable_send_notification : Optional [ bool ] = False ) -> schemas . Transfer : '''Use this method to send coins from your app's balance to a user. Args: user_id (int): Telegram user_id. asset (types.Assets): Currency. amount (float): Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use `get_exchange_rates` to convert amounts. spend_id (str): Unique ID to make your request idempotent and ensure that only one of the transfers with the same `spend_id` will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. comment (Optional[str], optional): Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. disable_send_notification (Optional[bool], optional): Pass `True` if the user should not receive a notification about the transfer. Defaults to False. Returns: types.Transfer: Object of completed `transfer`. ''' self . log . debug ( f 'Called with args ( { user_id } , { asset } , { amount } , { spend_id } , { comment } , { disable_send_notification } )' ) params = { 'user_id' : user_id , 'asset' : str ( asset ), 'amount' : amount , 'spend_id' : spend_id } if comment : params [ 'comment' ] = comment elif disable_send_notification : params [ 'disable_send_notification' ] = 'true' result = await self . _callApi ( 'POST' , 'transfer' , params ) return schemas . Transfer ( ** result ) async def process_webhook_update ( self , body : bytes , headers : dict ) -> schemas . Update : '''Process webhook update. Args: body (bytes): Update request body. headers (dict): Update request headers. Returns: types.Update: Webhook update. ''' self . log . debug ( f 'Called with args: ( { body } , { headers } )' ) # type: ignore update = schemas . Update ( ** loads ( body ), raw_body = body ) sign = headers . get ( 'crypto-pay-api-signature' , '' ) if not sign : raise UpdateSignatureError ( 'Not found signature!' , raw_response = update . dict (), raw_headers = headers ) if not update . check_signature ( self . api_key , sign ): raise UpdateSignatureError ( 'Signature validation error!' , raw_response = update . dict (), raw_headers = headers ) return update __init__ ( api_key , testnet = False ) Parameters: Name Type Description Default api_key str CryptoPay API token. required testnet bool Use Testnet? Defaults to False. False Source code in src/CryptoPayAPI/api.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , api_key : str , testnet : bool = False ) -> None : ''' Args: api_key (str): CryptoPay API token. testnet (bool): Use Testnet? Defaults to False. ''' self . timeout_sec = 5 self . log = logging . getLogger ( 'CryptoPay' ) self . api_key = api_key self . headers = { 'Crypto-Pay-API-Token' : api_key } self . testnet = testnet if testnet : self . endpoint = TESTHOST else : self . endpoint = MAINHOST self . client = AsyncClient ( headers = self . headers , base_url = self . endpoint , timeout = Timeout ( self . timeout_sec ) ) create_invoice ( asset , amount , description = None , hidden_message = None , paid_btn_name = None , paid_btn_url = None , payload = None , allow_comments = True , allow_anonymous = True , expires_in = None ) async Create a new invoice. Parameters: Name Type Description Default asset types . Assets Currency. required amount float Amount of invoice in float. required description Optional [ str ] Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. None hidden_message Optional [ str ] Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. None paid_btn_name Optional [ types . PaidButtonNames ] Name of the button that will be shown to a user after the invoice is paid. Defaults to None. None paid_btn_url Optional [ str ] Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. None payload Optional [ str ] Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. None allow_comments bool Allow a user to add a comment to the payment. Defaults to True. True allow_anonymous bool Allow a user to pay the invoice anonymously. Defaults to True. True expires_in Optional [ int ] You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. None Returns: Type Description schemas . Invoice types.Invoice: Object of the created invoice. Source code in src/CryptoPayAPI/api.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 async def create_invoice ( self , asset : schemas . Assets , amount : float , description : Optional [ str ] = None , hidden_message : Optional [ str ] = None , paid_btn_name : Optional [ schemas . PaidButtonNames ] = None , paid_btn_url : Optional [ str ] = None , payload : Optional [ str ] = None , allow_comments : bool = True , allow_anonymous : bool = True , expires_in : Optional [ int ] = None ) -> schemas . Invoice : '''Create a new invoice. Args: asset (types.Assets): Currency. amount (float): Amount of invoice in float. description (Optional[str]): Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. hidden_message (Optional[str]): Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. paid_btn_name (Optional[types.PaidButtonNames]): Name of the button that will be shown to a user after the invoice is paid. Defaults to None. paid_btn_url (Optional[str]): Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. payload (Optional[str]): Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. allow_comments (bool): Allow a user to add a comment to the payment. Defaults to True. allow_anonymous (bool): Allow a user to pay the invoice anonymously. Defaults to True. expires_in (Optional[int]): You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. Returns: types.Invoice: Object of the created invoice. ''' self . log . debug ( f 'Called with args ( { asset } , { amount } , { description } , { hidden_message } , { paid_btn_name } , { paid_btn_url } , { payload } , { allow_comments } , { allow_anonymous } , { expires_in } )' ) params = { 'asset' : str ( asset ), 'amount' : amount , 'allow_comments' : allow_comments , 'allow_anonymous' : allow_anonymous } if description : params [ 'description' ] = description elif hidden_message : params [ 'hidden_message' ] = hidden_message elif paid_btn_name : params [ 'paid_btn_name' ] = str ( paid_btn_name ) params [ 'paid_btn_url' ] = paid_btn_url elif payload : params [ 'payload' ] = payload elif expires_in : params [ 'expires_in' ] = expires_in result = await self . _callApi ( 'POST' , 'createInvoice' , params ) return schemas . Invoice ( ** result ) get_balance () async Use this method to get a balance of your app. Returns: Type Description List [ schemas . Balance ] List[types.Balance]: Array of assets. Source code in src/CryptoPayAPI/api.py 115 116 117 118 119 120 121 122 123 async def get_balance ( self ) -> List [ schemas . Balance ]: '''Use this method to get a balance of your app. Returns: List[types.Balance]: Array of assets. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getBalance' ) return [ schemas . Balance ( ** i ) for i in result ] get_currencies () async Use this method to get a list of supported currencies. Returns: Type Description List [ schemas . Currency ] List[types.Currency]: Array of currencies. Source code in src/CryptoPayAPI/api.py 135 136 137 138 139 140 141 142 143 async def get_currencies ( self ) -> List [ schemas . Currency ]: '''Use this method to get a list of supported currencies. Returns: List[types.Currency]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getCurrencies' ) return [ schemas . Currency ( ** i ) for i in result ] get_exchange_rates () async Use this method to get exchange rates of supported currencies. Returns: Type Description List [ schemas . ExchangeRate ] List[types.ExchangeRate]: Array of currencies. Source code in src/CryptoPayAPI/api.py 125 126 127 128 129 130 131 132 133 async def get_exchange_rates ( self ) -> List [ schemas . ExchangeRate ]: '''Use this method to get exchange rates of supported currencies. Returns: List[types.ExchangeRate]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getExchangeRates' ) return [ schemas . ExchangeRate ( ** i ) for i in result ] get_invoices ( asset = None , invoice_ids = None , status = None , offset = 0 , count = 100 ) async Use this method to get invoices of your app. Parameters: Name Type Description Default asset Optional [ types . Assets ] Currency codes separated by comma. Defaults to all assets. None invoice_ids Optional [ str ] Invoice IDs separated by comma. Defaults to None. None status Optional [ types . InvoiceStatus ] Status of invoices to be returned. Defaults to all statuses. None offset int Offset needed to return a specific subset of invoices. Defaults to 0. 0 count int Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. 100 Returns: Type Description List [ schemas . Invoice ] List[types.Invoice]: Array of invoices. Source code in src/CryptoPayAPI/api.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 async def get_invoices ( self , asset : Optional [ schemas . Assets ] = None , invoice_ids : Optional [ str ] = None , status : Optional [ schemas . InvoiceStatus ] = None , offset : int = 0 , count : int = 100 ) -> List [ schemas . Invoice ]: '''Use this method to get invoices of your app. Args: asset (Optional[types.Assets]): Currency codes separated by comma. Defaults to all assets. invoice_ids (Optional[str]): Invoice IDs separated by comma. Defaults to None. status (Optional[types.InvoiceStatus]): Status of invoices to be returned. Defaults to all statuses. offset (int): Offset needed to return a specific subset of invoices. Defaults to 0. count (int): Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. Returns: List[types.Invoice]: Array of invoices. ''' self . log . debug ( f 'Called with args ( { asset } , { invoice_ids } , { status } , { offset } , { count } )' ) params : Dict [ str , Union [ str , int ]] = { 'offset' : offset , 'count' : count } if asset : params [ 'asset' ] = str ( asset ) elif invoice_ids : params [ 'invoice_ids' ] = invoice_ids elif status : params [ 'status' ] = str ( status ) result = await self . _callApi ( 'GET' , 'getInvoices' , params ) return [ schemas . Invoice ( ** i ) for i in result [ 'items' ]] get_me () async Returns basic information about an app. Returns: Type Description schemas . Application types.Application: Basic information about an app. Source code in src/CryptoPayAPI/api.py 105 106 107 108 109 110 111 112 113 async def get_me ( self ) -> schemas . Application : '''Returns basic information about an app. Returns: types.Application: Basic information about an app. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getMe' ) return schemas . Application ( ** result ) process_webhook_update ( body , headers ) async Process webhook update. Parameters: Name Type Description Default body bytes Update request body. required headers dict Update request headers. required Returns: Type Description schemas . Update types.Update: Webhook update. Source code in src/CryptoPayAPI/api.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 async def process_webhook_update ( self , body : bytes , headers : dict ) -> schemas . Update : '''Process webhook update. Args: body (bytes): Update request body. headers (dict): Update request headers. Returns: types.Update: Webhook update. ''' self . log . debug ( f 'Called with args: ( { body } , { headers } )' ) # type: ignore update = schemas . Update ( ** loads ( body ), raw_body = body ) sign = headers . get ( 'crypto-pay-api-signature' , '' ) if not sign : raise UpdateSignatureError ( 'Not found signature!' , raw_response = update . dict (), raw_headers = headers ) if not update . check_signature ( self . api_key , sign ): raise UpdateSignatureError ( 'Signature validation error!' , raw_response = update . dict (), raw_headers = headers ) return update transfer ( user_id , asset , amount , spend_id , comment = None , disable_send_notification = False ) async Use this method to send coins from your app's balance to a user. Parameters: Name Type Description Default user_id int Telegram user_id. required asset types . Assets Currency. required amount float Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use get_exchange_rates to convert amounts. required spend_id str Unique ID to make your request idempotent and ensure that only one of the transfers with the same spend_id will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. required comment Optional [ str ] Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. None disable_send_notification Optional [ bool ] Pass True if the user should not receive a notification about the transfer. Defaults to False. False Returns: Type Description schemas . Transfer types.Transfer: Object of completed transfer . Source code in src/CryptoPayAPI/api.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 async def transfer ( self , user_id : int , asset : schemas . Assets , amount : float , spend_id : str , comment : Optional [ str ] = None , disable_send_notification : Optional [ bool ] = False ) -> schemas . Transfer : '''Use this method to send coins from your app's balance to a user. Args: user_id (int): Telegram user_id. asset (types.Assets): Currency. amount (float): Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use `get_exchange_rates` to convert amounts. spend_id (str): Unique ID to make your request idempotent and ensure that only one of the transfers with the same `spend_id` will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. comment (Optional[str], optional): Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. disable_send_notification (Optional[bool], optional): Pass `True` if the user should not receive a notification about the transfer. Defaults to False. Returns: types.Transfer: Object of completed `transfer`. ''' self . log . debug ( f 'Called with args ( { user_id } , { asset } , { amount } , { spend_id } , { comment } , { disable_send_notification } )' ) params = { 'user_id' : user_id , 'asset' : str ( asset ), 'amount' : amount , 'spend_id' : spend_id } if comment : params [ 'comment' ] = comment elif disable_send_notification : params [ 'disable_send_notification' ] = 'true' result = await self . _callApi ( 'POST' , 'transfer' , params ) return schemas . Transfer ( ** result )","title":"CryptoPay"},{"location":"API/CryptoPayAPI/#cryptopay","text":"","title":"\u041a\u043b\u0430\u0441\u0441 CryptoPay"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay","text":"CryptoPay payment system. Source code in src/CryptoPayAPI/api.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class CryptoPay : '''CryptoPay payment system. ''' def __init__ ( self , api_key : str , testnet : bool = False ) -> None : ''' Args: api_key (str): CryptoPay API token. testnet (bool): Use Testnet? Defaults to False. ''' self . timeout_sec = 5 self . log = logging . getLogger ( 'CryptoPay' ) self . api_key = api_key self . headers = { 'Crypto-Pay-API-Token' : api_key } self . testnet = testnet if testnet : self . endpoint = TESTHOST else : self . endpoint = MAINHOST self . client = AsyncClient ( headers = self . headers , base_url = self . endpoint , timeout = Timeout ( self . timeout_sec ) ) async def _callApi ( self , http_method : str , api_method : str , query : dict = {}) -> dict : '''Makes a api call. Args: http_method (str): HTTP method. Available is \"GET\" and \"POST\". api_method (str): API method. query (dict, optional): Request query in dict. Defaults to {}. Returns: dict: API response as JSON dict viceversa None. ''' self . log . debug ( f 'Called with args ( { http_method } , { api_method } , { query } )' ) if query : params = urllib . parse . urlencode ( query ) else : params = None resp = await self . client . request ( http_method , api_method , params = params ) if resp . is_success : data = resp . json () self . log . debug ( f 'API answer: { data } ' ) if data [ 'ok' ]: return data [ 'result' ] else : raise UnexpectedError ( f '[ { data [ \"error\" ][ \"code\" ] } ] { data [ \"error\" ][ \"name\" ] } ' , data ) else : if resp . status_code == 401 : raise UnauthorizedError ( 'Token not found!' ) elif resp . status_code == 405 : raise MethodNotFoundError ( f 'Method { api_method } not found!' ) elif resp . status_code == 400 : data = resp . json () err = data [ 'error' ][ 'name' ] if err == 'EXPIRES_IN_INVALID' : raise ExpiresInInvalidError ( f 'Expires \" { query [ \"expires_in\" ] } \" is invalid!' , raw_response = data ) elif resp . status_code == 403 : data = resp . json () err = data [ 'error' ][ 'name' ] if err == 'METHOD_DISABLED' : raise MethodDisabledError ( f 'Method \" { api_method } \" is disabled!' , raw_response = data ) data = resp . json () raise UnexpectedError ( f '[ { data [ \"error\" ][ \"code\" ] } ] { data [ \"error\" ][ \"name\" ] } ' , raw_response = data ) async def get_me ( self ) -> schemas . Application : '''Returns basic information about an app. Returns: types.Application: Basic information about an app. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getMe' ) return schemas . Application ( ** result ) async def get_balance ( self ) -> List [ schemas . Balance ]: '''Use this method to get a balance of your app. Returns: List[types.Balance]: Array of assets. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getBalance' ) return [ schemas . Balance ( ** i ) for i in result ] async def get_exchange_rates ( self ) -> List [ schemas . ExchangeRate ]: '''Use this method to get exchange rates of supported currencies. Returns: List[types.ExchangeRate]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getExchangeRates' ) return [ schemas . ExchangeRate ( ** i ) for i in result ] async def get_currencies ( self ) -> List [ schemas . Currency ]: '''Use this method to get a list of supported currencies. Returns: List[types.Currency]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getCurrencies' ) return [ schemas . Currency ( ** i ) for i in result ] async def create_invoice ( self , asset : schemas . Assets , amount : float , description : Optional [ str ] = None , hidden_message : Optional [ str ] = None , paid_btn_name : Optional [ schemas . PaidButtonNames ] = None , paid_btn_url : Optional [ str ] = None , payload : Optional [ str ] = None , allow_comments : bool = True , allow_anonymous : bool = True , expires_in : Optional [ int ] = None ) -> schemas . Invoice : '''Create a new invoice. Args: asset (types.Assets): Currency. amount (float): Amount of invoice in float. description (Optional[str]): Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. hidden_message (Optional[str]): Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. paid_btn_name (Optional[types.PaidButtonNames]): Name of the button that will be shown to a user after the invoice is paid. Defaults to None. paid_btn_url (Optional[str]): Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. payload (Optional[str]): Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. allow_comments (bool): Allow a user to add a comment to the payment. Defaults to True. allow_anonymous (bool): Allow a user to pay the invoice anonymously. Defaults to True. expires_in (Optional[int]): You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. Returns: types.Invoice: Object of the created invoice. ''' self . log . debug ( f 'Called with args ( { asset } , { amount } , { description } , { hidden_message } , { paid_btn_name } , { paid_btn_url } , { payload } , { allow_comments } , { allow_anonymous } , { expires_in } )' ) params = { 'asset' : str ( asset ), 'amount' : amount , 'allow_comments' : allow_comments , 'allow_anonymous' : allow_anonymous } if description : params [ 'description' ] = description elif hidden_message : params [ 'hidden_message' ] = hidden_message elif paid_btn_name : params [ 'paid_btn_name' ] = str ( paid_btn_name ) params [ 'paid_btn_url' ] = paid_btn_url elif payload : params [ 'payload' ] = payload elif expires_in : params [ 'expires_in' ] = expires_in result = await self . _callApi ( 'POST' , 'createInvoice' , params ) return schemas . Invoice ( ** result ) async def get_invoices ( self , asset : Optional [ schemas . Assets ] = None , invoice_ids : Optional [ str ] = None , status : Optional [ schemas . InvoiceStatus ] = None , offset : int = 0 , count : int = 100 ) -> List [ schemas . Invoice ]: '''Use this method to get invoices of your app. Args: asset (Optional[types.Assets]): Currency codes separated by comma. Defaults to all assets. invoice_ids (Optional[str]): Invoice IDs separated by comma. Defaults to None. status (Optional[types.InvoiceStatus]): Status of invoices to be returned. Defaults to all statuses. offset (int): Offset needed to return a specific subset of invoices. Defaults to 0. count (int): Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. Returns: List[types.Invoice]: Array of invoices. ''' self . log . debug ( f 'Called with args ( { asset } , { invoice_ids } , { status } , { offset } , { count } )' ) params : Dict [ str , Union [ str , int ]] = { 'offset' : offset , 'count' : count } if asset : params [ 'asset' ] = str ( asset ) elif invoice_ids : params [ 'invoice_ids' ] = invoice_ids elif status : params [ 'status' ] = str ( status ) result = await self . _callApi ( 'GET' , 'getInvoices' , params ) return [ schemas . Invoice ( ** i ) for i in result [ 'items' ]] async def transfer ( self , user_id : int , asset : schemas . Assets , amount : float , spend_id : str , comment : Optional [ str ] = None , disable_send_notification : Optional [ bool ] = False ) -> schemas . Transfer : '''Use this method to send coins from your app's balance to a user. Args: user_id (int): Telegram user_id. asset (types.Assets): Currency. amount (float): Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use `get_exchange_rates` to convert amounts. spend_id (str): Unique ID to make your request idempotent and ensure that only one of the transfers with the same `spend_id` will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. comment (Optional[str], optional): Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. disable_send_notification (Optional[bool], optional): Pass `True` if the user should not receive a notification about the transfer. Defaults to False. Returns: types.Transfer: Object of completed `transfer`. ''' self . log . debug ( f 'Called with args ( { user_id } , { asset } , { amount } , { spend_id } , { comment } , { disable_send_notification } )' ) params = { 'user_id' : user_id , 'asset' : str ( asset ), 'amount' : amount , 'spend_id' : spend_id } if comment : params [ 'comment' ] = comment elif disable_send_notification : params [ 'disable_send_notification' ] = 'true' result = await self . _callApi ( 'POST' , 'transfer' , params ) return schemas . Transfer ( ** result ) async def process_webhook_update ( self , body : bytes , headers : dict ) -> schemas . Update : '''Process webhook update. Args: body (bytes): Update request body. headers (dict): Update request headers. Returns: types.Update: Webhook update. ''' self . log . debug ( f 'Called with args: ( { body } , { headers } )' ) # type: ignore update = schemas . Update ( ** loads ( body ), raw_body = body ) sign = headers . get ( 'crypto-pay-api-signature' , '' ) if not sign : raise UpdateSignatureError ( 'Not found signature!' , raw_response = update . dict (), raw_headers = headers ) if not update . check_signature ( self . api_key , sign ): raise UpdateSignatureError ( 'Signature validation error!' , raw_response = update . dict (), raw_headers = headers ) return update","title":"CryptoPay"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.__init__","text":"Parameters: Name Type Description Default api_key str CryptoPay API token. required testnet bool Use Testnet? Defaults to False. False Source code in src/CryptoPayAPI/api.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , api_key : str , testnet : bool = False ) -> None : ''' Args: api_key (str): CryptoPay API token. testnet (bool): Use Testnet? Defaults to False. ''' self . timeout_sec = 5 self . log = logging . getLogger ( 'CryptoPay' ) self . api_key = api_key self . headers = { 'Crypto-Pay-API-Token' : api_key } self . testnet = testnet if testnet : self . endpoint = TESTHOST else : self . endpoint = MAINHOST self . client = AsyncClient ( headers = self . headers , base_url = self . endpoint , timeout = Timeout ( self . timeout_sec ) )","title":"__init__()"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.create_invoice","text":"Create a new invoice. Parameters: Name Type Description Default asset types . Assets Currency. required amount float Amount of invoice in float. required description Optional [ str ] Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. None hidden_message Optional [ str ] Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. None paid_btn_name Optional [ types . PaidButtonNames ] Name of the button that will be shown to a user after the invoice is paid. Defaults to None. None paid_btn_url Optional [ str ] Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. None payload Optional [ str ] Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. None allow_comments bool Allow a user to add a comment to the payment. Defaults to True. True allow_anonymous bool Allow a user to pay the invoice anonymously. Defaults to True. True expires_in Optional [ int ] You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. None Returns: Type Description schemas . Invoice types.Invoice: Object of the created invoice. Source code in src/CryptoPayAPI/api.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 async def create_invoice ( self , asset : schemas . Assets , amount : float , description : Optional [ str ] = None , hidden_message : Optional [ str ] = None , paid_btn_name : Optional [ schemas . PaidButtonNames ] = None , paid_btn_url : Optional [ str ] = None , payload : Optional [ str ] = None , allow_comments : bool = True , allow_anonymous : bool = True , expires_in : Optional [ int ] = None ) -> schemas . Invoice : '''Create a new invoice. Args: asset (types.Assets): Currency. amount (float): Amount of invoice in float. description (Optional[str]): Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. hidden_message (Optional[str]): Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. paid_btn_name (Optional[types.PaidButtonNames]): Name of the button that will be shown to a user after the invoice is paid. Defaults to None. paid_btn_url (Optional[str]): Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. payload (Optional[str]): Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. allow_comments (bool): Allow a user to add a comment to the payment. Defaults to True. allow_anonymous (bool): Allow a user to pay the invoice anonymously. Defaults to True. expires_in (Optional[int]): You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. Returns: types.Invoice: Object of the created invoice. ''' self . log . debug ( f 'Called with args ( { asset } , { amount } , { description } , { hidden_message } , { paid_btn_name } , { paid_btn_url } , { payload } , { allow_comments } , { allow_anonymous } , { expires_in } )' ) params = { 'asset' : str ( asset ), 'amount' : amount , 'allow_comments' : allow_comments , 'allow_anonymous' : allow_anonymous } if description : params [ 'description' ] = description elif hidden_message : params [ 'hidden_message' ] = hidden_message elif paid_btn_name : params [ 'paid_btn_name' ] = str ( paid_btn_name ) params [ 'paid_btn_url' ] = paid_btn_url elif payload : params [ 'payload' ] = payload elif expires_in : params [ 'expires_in' ] = expires_in result = await self . _callApi ( 'POST' , 'createInvoice' , params ) return schemas . Invoice ( ** result )","title":"create_invoice()"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.get_balance","text":"Use this method to get a balance of your app. Returns: Type Description List [ schemas . Balance ] List[types.Balance]: Array of assets. Source code in src/CryptoPayAPI/api.py 115 116 117 118 119 120 121 122 123 async def get_balance ( self ) -> List [ schemas . Balance ]: '''Use this method to get a balance of your app. Returns: List[types.Balance]: Array of assets. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getBalance' ) return [ schemas . Balance ( ** i ) for i in result ]","title":"get_balance()"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.get_currencies","text":"Use this method to get a list of supported currencies. Returns: Type Description List [ schemas . Currency ] List[types.Currency]: Array of currencies. Source code in src/CryptoPayAPI/api.py 135 136 137 138 139 140 141 142 143 async def get_currencies ( self ) -> List [ schemas . Currency ]: '''Use this method to get a list of supported currencies. Returns: List[types.Currency]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getCurrencies' ) return [ schemas . Currency ( ** i ) for i in result ]","title":"get_currencies()"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.get_exchange_rates","text":"Use this method to get exchange rates of supported currencies. Returns: Type Description List [ schemas . ExchangeRate ] List[types.ExchangeRate]: Array of currencies. Source code in src/CryptoPayAPI/api.py 125 126 127 128 129 130 131 132 133 async def get_exchange_rates ( self ) -> List [ schemas . ExchangeRate ]: '''Use this method to get exchange rates of supported currencies. Returns: List[types.ExchangeRate]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getExchangeRates' ) return [ schemas . ExchangeRate ( ** i ) for i in result ]","title":"get_exchange_rates()"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.get_invoices","text":"Use this method to get invoices of your app. Parameters: Name Type Description Default asset Optional [ types . Assets ] Currency codes separated by comma. Defaults to all assets. None invoice_ids Optional [ str ] Invoice IDs separated by comma. Defaults to None. None status Optional [ types . InvoiceStatus ] Status of invoices to be returned. Defaults to all statuses. None offset int Offset needed to return a specific subset of invoices. Defaults to 0. 0 count int Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. 100 Returns: Type Description List [ schemas . Invoice ] List[types.Invoice]: Array of invoices. Source code in src/CryptoPayAPI/api.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 async def get_invoices ( self , asset : Optional [ schemas . Assets ] = None , invoice_ids : Optional [ str ] = None , status : Optional [ schemas . InvoiceStatus ] = None , offset : int = 0 , count : int = 100 ) -> List [ schemas . Invoice ]: '''Use this method to get invoices of your app. Args: asset (Optional[types.Assets]): Currency codes separated by comma. Defaults to all assets. invoice_ids (Optional[str]): Invoice IDs separated by comma. Defaults to None. status (Optional[types.InvoiceStatus]): Status of invoices to be returned. Defaults to all statuses. offset (int): Offset needed to return a specific subset of invoices. Defaults to 0. count (int): Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. Returns: List[types.Invoice]: Array of invoices. ''' self . log . debug ( f 'Called with args ( { asset } , { invoice_ids } , { status } , { offset } , { count } )' ) params : Dict [ str , Union [ str , int ]] = { 'offset' : offset , 'count' : count } if asset : params [ 'asset' ] = str ( asset ) elif invoice_ids : params [ 'invoice_ids' ] = invoice_ids elif status : params [ 'status' ] = str ( status ) result = await self . _callApi ( 'GET' , 'getInvoices' , params ) return [ schemas . Invoice ( ** i ) for i in result [ 'items' ]]","title":"get_invoices()"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.get_me","text":"Returns basic information about an app. Returns: Type Description schemas . Application types.Application: Basic information about an app. Source code in src/CryptoPayAPI/api.py 105 106 107 108 109 110 111 112 113 async def get_me ( self ) -> schemas . Application : '''Returns basic information about an app. Returns: types.Application: Basic information about an app. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getMe' ) return schemas . Application ( ** result )","title":"get_me()"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.process_webhook_update","text":"Process webhook update. Parameters: Name Type Description Default body bytes Update request body. required headers dict Update request headers. required Returns: Type Description schemas . Update types.Update: Webhook update. Source code in src/CryptoPayAPI/api.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 async def process_webhook_update ( self , body : bytes , headers : dict ) -> schemas . Update : '''Process webhook update. Args: body (bytes): Update request body. headers (dict): Update request headers. Returns: types.Update: Webhook update. ''' self . log . debug ( f 'Called with args: ( { body } , { headers } )' ) # type: ignore update = schemas . Update ( ** loads ( body ), raw_body = body ) sign = headers . get ( 'crypto-pay-api-signature' , '' ) if not sign : raise UpdateSignatureError ( 'Not found signature!' , raw_response = update . dict (), raw_headers = headers ) if not update . check_signature ( self . api_key , sign ): raise UpdateSignatureError ( 'Signature validation error!' , raw_response = update . dict (), raw_headers = headers ) return update","title":"process_webhook_update()"},{"location":"API/CryptoPayAPI/#src.CryptoPayAPI.api.CryptoPay.transfer","text":"Use this method to send coins from your app's balance to a user. Parameters: Name Type Description Default user_id int Telegram user_id. required asset types . Assets Currency. required amount float Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use get_exchange_rates to convert amounts. required spend_id str Unique ID to make your request idempotent and ensure that only one of the transfers with the same spend_id will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. required comment Optional [ str ] Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. None disable_send_notification Optional [ bool ] Pass True if the user should not receive a notification about the transfer. Defaults to False. False Returns: Type Description schemas . Transfer types.Transfer: Object of completed transfer . Source code in src/CryptoPayAPI/api.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 async def transfer ( self , user_id : int , asset : schemas . Assets , amount : float , spend_id : str , comment : Optional [ str ] = None , disable_send_notification : Optional [ bool ] = False ) -> schemas . Transfer : '''Use this method to send coins from your app's balance to a user. Args: user_id (int): Telegram user_id. asset (types.Assets): Currency. amount (float): Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use `get_exchange_rates` to convert amounts. spend_id (str): Unique ID to make your request idempotent and ensure that only one of the transfers with the same `spend_id` will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. comment (Optional[str], optional): Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. disable_send_notification (Optional[bool], optional): Pass `True` if the user should not receive a notification about the transfer. Defaults to False. Returns: types.Transfer: Object of completed `transfer`. ''' self . log . debug ( f 'Called with args ( { user_id } , { asset } , { amount } , { spend_id } , { comment } , { disable_send_notification } )' ) params = { 'user_id' : user_id , 'asset' : str ( asset ), 'amount' : amount , 'spend_id' : spend_id } if comment : params [ 'comment' ] = comment elif disable_send_notification : params [ 'disable_send_notification' ] = 'true' result = await self . _callApi ( 'POST' , 'transfer' , params ) return schemas . Transfer ( ** result )","title":"transfer()"},{"location":"API/CryptoPayAPI/schemas/","text":"\u0421\u0445\u0435\u043c\u044b Application Bases: BaseModel Application info. Attributes: Name Type Description app_id int Application unique ID. name str Application name. payment_processing_bot_username str Username of Crypto bot. Source code in src/CryptoPayAPI/schemas.py 153 154 155 156 157 158 159 160 161 162 163 class Application ( BaseModel ): '''Application info. Attributes: app_id (int): Application unique ID. name (str): Application name. payment_processing_bot_username (str): Username of Crypto bot. ''' app_id : int name : str payment_processing_bot_username : str Assets Bases: Enum Currency code. Attributes: Name Type Description BTC str Bitcoin TON str Toncoin ETH str Ethereum USDT str Tether USDC str USD Coin BUSD str Binance USD Source code in src/CryptoPayAPI/schemas.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Assets ( Enum ): '''Currency code. Attributes: BTC (str): Bitcoin TON (str): Toncoin ETH (str): Ethereum USDT (str): Tether USDC (str): USD Coin BUSD (str): Binance USD ''' BTC = 'BTC' TON = 'TON' ETH = 'ETH' USDT = 'USDT' USDC = 'USDC' BUSD = 'BUSD' def __str__ ( self ) -> str : return self . value Balance Bases: BaseModel Balance info. Attributes: Name Type Description currency_code str Currency code. available Decimal Available for using. Source code in src/CryptoPayAPI/schemas.py 166 167 168 169 170 171 172 173 174 class Balance ( BaseModel ): '''Balance info. Attributes: currency_code (str): Currency code. available (Decimal): Available for using. ''' currency_code : str available : Decimal Currency Bases: BaseModel Currency info. Attributes: Name Type Description is_blockchain bool Is blockchain asset? is_stablecoin bool Is stable coin? is_fiat bool Is fiat asset? name str Name of currency. code str Code of currency. url Optional [ str ] Optional . URL of currency site. decimals int ? Source code in src/CryptoPayAPI/schemas.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class Currency ( BaseModel ): '''Currency info. Attributes: is_blockchain (bool): Is blockchain asset? is_stablecoin (bool): Is stable coin? is_fiat (bool): Is fiat asset? name (str): Name of currency. code (str): Code of currency. url (Optional[str]): *Optional*. URL of currency site. decimals (int): ? ''' is_blockchain : bool is_stablecoin : bool is_fiat : bool name : str code : str url : Optional [ str ] decimals : int ExchangeRate Bases: BaseModel Exchange rate info. Attributes: Name Type Description is_valid bool Is valid? source str Source asset. target str Target asset. rate Decimal Exchange rate. Source code in src/CryptoPayAPI/schemas.py 177 178 179 180 181 182 183 184 185 186 187 188 189 class ExchangeRate ( BaseModel ): '''Exchange rate info. Attributes: is_valid (bool): Is valid? source (str): Source asset. target (str): Target asset. rate (Decimal): Exchange rate. ''' is_valid : bool source : str target : str rate : Decimal Invoice Bases: BaseModel Invoice info. Attributes: Name Type Description invoice_id int Unique ID for this invoice. status InvoiceStatus Status of the invoice. hash str Hash of the invoice. asset Assets Currency code. amount Decimal Amount of the invoice. pay_url str URL should be presented to the user to pay the invoice. description Optional [ str ] Optional . Description for this invoice. created_at datetime Date the invoice was created in ISO 8601 format. allow_comments bool True , if the user can add comment to the payment. allow_anonymous bool True , if the user can pay the invoice anonymously. expiration_date Optional [ datetime ] Optional . Date the invoice expires in Unix time. paid_at Optional [ datetime ] Optional . Date the invoice was paid in Unix time. paid_anonymously Optional [ bool ] True , if the invoice was paid anonymously. comment Optional [ str ] Optional . Comment to the payment from the user. hidden_message Optional [ str ] Optional . Text of the hidden message for this invoice. payload Optional [ str ] Optional . Previously provided data for this invoice. paid_btn_name Optional [ PaidButtonNames ] Optional . Name of the button. paid_btn_url Optional [ str ] Optional . URL of the button. fee Optional [ Decimal ] Optional . Amount of charged service fees. Returned only if the invoice has paid status. usd_rate Optional [ Decimal ] Optional . Price of the asset in USD. Returned only if the invoice has paid status. Source code in src/CryptoPayAPI/schemas.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class Invoice ( BaseModel ): '''Invoice info. Attributes: invoice_id (int): Unique ID for this invoice. status (InvoiceStatus): Status of the invoice. hash (str): Hash of the invoice. asset (Assets): Currency code. amount (Decimal): Amount of the invoice. pay_url (str): URL should be presented to the user to pay the invoice. description (Optional[str]): *Optional*. Description for this invoice. created_at (datetime): Date the invoice was created in ISO 8601 format. allow_comments (bool): `True`, if the user can add comment to the payment. allow_anonymous (bool): `True`, if the user can pay the invoice anonymously. expiration_date (Optional[datetime]): *Optional*. Date the invoice expires in Unix time. paid_at (Optional[datetime]): *Optional*. Date the invoice was paid in Unix time. paid_anonymously (Optional[bool]): `True`, if the invoice was paid anonymously. comment (Optional[str]): *Optional*. Comment to the payment from the user. hidden_message (Optional[str]): *Optional*. Text of the hidden message for this invoice. payload (Optional[str]): *Optional*. Previously provided data for this invoice. paid_btn_name (Optional[PaidButtonNames]): *Optional*. Name of the button. paid_btn_url (Optional[str]): *Optional*. URL of the button. fee (Optional[Decimal]): *Optional*. Amount of charged service fees. Returned only if the invoice has paid status. usd_rate (Optional[Decimal]): *Optional*. Price of the asset in USD. Returned only if the invoice has paid status. ''' invoice_id : int status : InvoiceStatus hash : str asset : Assets amount : Decimal pay_url : str description : Optional [ str ] created_at : datetime allow_comments : bool allow_anonymous : bool expiration_date : Optional [ datetime ] paid_at : Optional [ datetime ] paid_anonymously : Optional [ bool ] comment : Optional [ str ] hidden_message : Optional [ str ] payload : Optional [ str ] paid_btn_name : Optional [ PaidButtonNames ] paid_btn_url : Optional [ str ] fee : Optional [ Decimal ] usd_rate : Optional [ Decimal ] InvoiceStatus Bases: Enum Status of invoice. Attributes: Name Type Description ACTIVE str 'active' PAID str 'paid' EXPIRED str 'expired' Source code in src/CryptoPayAPI/schemas.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class InvoiceStatus ( Enum ): '''Status of invoice. Attributes: ACTIVE (str): 'active' PAID (str): 'paid' EXPIRED (str): 'expired' ''' ACTIVE = 'active' PAID = 'paid' EXPIRED = 'expired' def __str__ ( self ) -> str : return self . value PaidButtonNames Bases: Enum Name of the button. Attributes: Name Type Description VIEW_ITEM str 'viewItem' OPEN_CHANNEL str 'openChannel' OPEN_BOT str 'openBot' CALLBACK str 'callback' Source code in src/CryptoPayAPI/schemas.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class PaidButtonNames ( Enum ): '''Name of the button. Attributes: VIEW_ITEM (str): 'viewItem' OPEN_CHANNEL (str): 'openChannel' OPEN_BOT (str): 'openBot' CALLBACK (str): 'callback' ''' VIEW_ITEM = 'viewItem' OPEN_CHANNEL = 'openChannel' OPEN_BOT = 'openBot' CALLBACK = 'callback' def __str__ ( self ) -> str : return self . value Transfer Bases: BaseModel Transfer info. Attributes: Name Type Description transfer_id int Unique ID for this transfer. user_id int Telegram user ID the transfer was sent to. asset Assets Currency code. amount Decimal Amount of the transfer. status Literal ['completed'] Status of the transfer, can be \u201ccompleted\u201d. completed_at datetime Date the transfer was completed in ISO 8601 format. comment Optional [ str ] Optional . Comment for this transfer. Source code in src/CryptoPayAPI/schemas.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class Transfer ( BaseModel ): '''Transfer info. Attributes: transfer_id (int): Unique ID for this transfer. user_id (int): Telegram user ID the transfer was sent to. asset (Assets): Currency code. amount (Decimal): Amount of the transfer. status (Literal['completed']): Status of the transfer, can be \u201ccompleted\u201d. completed_at (datetime): Date the transfer was completed in ISO 8601 format. comment (Optional[str]): *Optional*. Comment for this transfer. ''' transfer_id : int user_id : int asset : Assets amount : Decimal status : Literal [ 'completed' ] completed_at : datetime comment : Optional [ str ] Update Bases: BaseModel Webhook update object. Attributes: Name Type Description update_id int Non-unique update ID. update_type UpdateType Webhook update type. request_date datetime Date the request was sent in ISO 8601 format. payload Invoice Payload contains Invoice object. raw_body Optional [ bytes ] Optional . Raw body of update, for check sign purpose. Source code in src/CryptoPayAPI/schemas.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 class Update ( BaseModel ): '''Webhook update object. Attributes: update_id (int): Non-unique update ID. update_type (UpdateType): Webhook update type. request_date (datetime): Date the request was sent in ISO 8601 format. payload (Invoice): Payload contains `Invoice` object. raw_body (Optional[bytes]): *Optional*. Raw body of update, for check sign purpose. ''' update_id : int update_type : UpdateType request_date : datetime payload : Invoice raw_body : Optional [ bytes ] = None def check_signature ( self , api_key : str , sign : str ) -> bool : '''Check update signature. Args: api_key (str): CryptoPay app API key. sign (str): Update signature. In request headers `crypto-pay-api-signature`. Returns: bool: Is signature verified? ''' log . debug ( f 'Called with args: ( { api_key } , { sign } )' ) secret = sha256 ( api_key . encode ()) . digest () hmac = HMAC ( secret , self . raw_body , digestmod = sha256 ) body_sign = hmac . hexdigest () log . debug ( f 'Calculated hash: { body_sign } ' ) return body_sign == sign check_signature ( api_key , sign ) Check update signature. Parameters: Name Type Description Default api_key str CryptoPay app API key. required sign str Update signature. In request headers crypto-pay-api-signature . required Returns: Name Type Description bool bool Is signature verified? Source code in src/CryptoPayAPI/schemas.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def check_signature ( self , api_key : str , sign : str ) -> bool : '''Check update signature. Args: api_key (str): CryptoPay app API key. sign (str): Update signature. In request headers `crypto-pay-api-signature`. Returns: bool: Is signature verified? ''' log . debug ( f 'Called with args: ( { api_key } , { sign } )' ) secret = sha256 ( api_key . encode ()) . digest () hmac = HMAC ( secret , self . raw_body , digestmod = sha256 ) body_sign = hmac . hexdigest () log . debug ( f 'Calculated hash: { body_sign } ' ) return body_sign == sign UpdateType Bases: Enum Webhook update type. Attributes: Name Type Description INVOICE_PAID str 'invoice_paid Source code in src/CryptoPayAPI/schemas.py 76 77 78 79 80 81 82 class UpdateType ( Enum ): '''Webhook update type. Attributes: INVOICE_PAID (str): 'invoice_paid ''' INVOICE_PAID = 'invoice_paid'","title":"\u0421\u0445\u0435\u043c\u044b"},{"location":"API/CryptoPayAPI/schemas/#_1","text":"","title":"\u0421\u0445\u0435\u043c\u044b"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.Application","text":"Bases: BaseModel Application info. Attributes: Name Type Description app_id int Application unique ID. name str Application name. payment_processing_bot_username str Username of Crypto bot. Source code in src/CryptoPayAPI/schemas.py 153 154 155 156 157 158 159 160 161 162 163 class Application ( BaseModel ): '''Application info. Attributes: app_id (int): Application unique ID. name (str): Application name. payment_processing_bot_username (str): Username of Crypto bot. ''' app_id : int name : str payment_processing_bot_username : str","title":"Application"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.Assets","text":"Bases: Enum Currency code. Attributes: Name Type Description BTC str Bitcoin TON str Toncoin ETH str Ethereum USDT str Tether USDC str USD Coin BUSD str Binance USD Source code in src/CryptoPayAPI/schemas.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Assets ( Enum ): '''Currency code. Attributes: BTC (str): Bitcoin TON (str): Toncoin ETH (str): Ethereum USDT (str): Tether USDC (str): USD Coin BUSD (str): Binance USD ''' BTC = 'BTC' TON = 'TON' ETH = 'ETH' USDT = 'USDT' USDC = 'USDC' BUSD = 'BUSD' def __str__ ( self ) -> str : return self . value","title":"Assets"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.Balance","text":"Bases: BaseModel Balance info. Attributes: Name Type Description currency_code str Currency code. available Decimal Available for using. Source code in src/CryptoPayAPI/schemas.py 166 167 168 169 170 171 172 173 174 class Balance ( BaseModel ): '''Balance info. Attributes: currency_code (str): Currency code. available (Decimal): Available for using. ''' currency_code : str available : Decimal","title":"Balance"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.Currency","text":"Bases: BaseModel Currency info. Attributes: Name Type Description is_blockchain bool Is blockchain asset? is_stablecoin bool Is stable coin? is_fiat bool Is fiat asset? name str Name of currency. code str Code of currency. url Optional [ str ] Optional . URL of currency site. decimals int ? Source code in src/CryptoPayAPI/schemas.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class Currency ( BaseModel ): '''Currency info. Attributes: is_blockchain (bool): Is blockchain asset? is_stablecoin (bool): Is stable coin? is_fiat (bool): Is fiat asset? name (str): Name of currency. code (str): Code of currency. url (Optional[str]): *Optional*. URL of currency site. decimals (int): ? ''' is_blockchain : bool is_stablecoin : bool is_fiat : bool name : str code : str url : Optional [ str ] decimals : int","title":"Currency"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.ExchangeRate","text":"Bases: BaseModel Exchange rate info. Attributes: Name Type Description is_valid bool Is valid? source str Source asset. target str Target asset. rate Decimal Exchange rate. Source code in src/CryptoPayAPI/schemas.py 177 178 179 180 181 182 183 184 185 186 187 188 189 class ExchangeRate ( BaseModel ): '''Exchange rate info. Attributes: is_valid (bool): Is valid? source (str): Source asset. target (str): Target asset. rate (Decimal): Exchange rate. ''' is_valid : bool source : str target : str rate : Decimal","title":"ExchangeRate"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.Invoice","text":"Bases: BaseModel Invoice info. Attributes: Name Type Description invoice_id int Unique ID for this invoice. status InvoiceStatus Status of the invoice. hash str Hash of the invoice. asset Assets Currency code. amount Decimal Amount of the invoice. pay_url str URL should be presented to the user to pay the invoice. description Optional [ str ] Optional . Description for this invoice. created_at datetime Date the invoice was created in ISO 8601 format. allow_comments bool True , if the user can add comment to the payment. allow_anonymous bool True , if the user can pay the invoice anonymously. expiration_date Optional [ datetime ] Optional . Date the invoice expires in Unix time. paid_at Optional [ datetime ] Optional . Date the invoice was paid in Unix time. paid_anonymously Optional [ bool ] True , if the invoice was paid anonymously. comment Optional [ str ] Optional . Comment to the payment from the user. hidden_message Optional [ str ] Optional . Text of the hidden message for this invoice. payload Optional [ str ] Optional . Previously provided data for this invoice. paid_btn_name Optional [ PaidButtonNames ] Optional . Name of the button. paid_btn_url Optional [ str ] Optional . URL of the button. fee Optional [ Decimal ] Optional . Amount of charged service fees. Returned only if the invoice has paid status. usd_rate Optional [ Decimal ] Optional . Price of the asset in USD. Returned only if the invoice has paid status. Source code in src/CryptoPayAPI/schemas.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class Invoice ( BaseModel ): '''Invoice info. Attributes: invoice_id (int): Unique ID for this invoice. status (InvoiceStatus): Status of the invoice. hash (str): Hash of the invoice. asset (Assets): Currency code. amount (Decimal): Amount of the invoice. pay_url (str): URL should be presented to the user to pay the invoice. description (Optional[str]): *Optional*. Description for this invoice. created_at (datetime): Date the invoice was created in ISO 8601 format. allow_comments (bool): `True`, if the user can add comment to the payment. allow_anonymous (bool): `True`, if the user can pay the invoice anonymously. expiration_date (Optional[datetime]): *Optional*. Date the invoice expires in Unix time. paid_at (Optional[datetime]): *Optional*. Date the invoice was paid in Unix time. paid_anonymously (Optional[bool]): `True`, if the invoice was paid anonymously. comment (Optional[str]): *Optional*. Comment to the payment from the user. hidden_message (Optional[str]): *Optional*. Text of the hidden message for this invoice. payload (Optional[str]): *Optional*. Previously provided data for this invoice. paid_btn_name (Optional[PaidButtonNames]): *Optional*. Name of the button. paid_btn_url (Optional[str]): *Optional*. URL of the button. fee (Optional[Decimal]): *Optional*. Amount of charged service fees. Returned only if the invoice has paid status. usd_rate (Optional[Decimal]): *Optional*. Price of the asset in USD. Returned only if the invoice has paid status. ''' invoice_id : int status : InvoiceStatus hash : str asset : Assets amount : Decimal pay_url : str description : Optional [ str ] created_at : datetime allow_comments : bool allow_anonymous : bool expiration_date : Optional [ datetime ] paid_at : Optional [ datetime ] paid_anonymously : Optional [ bool ] comment : Optional [ str ] hidden_message : Optional [ str ] payload : Optional [ str ] paid_btn_name : Optional [ PaidButtonNames ] paid_btn_url : Optional [ str ] fee : Optional [ Decimal ] usd_rate : Optional [ Decimal ]","title":"Invoice"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.InvoiceStatus","text":"Bases: Enum Status of invoice. Attributes: Name Type Description ACTIVE str 'active' PAID str 'paid' EXPIRED str 'expired' Source code in src/CryptoPayAPI/schemas.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class InvoiceStatus ( Enum ): '''Status of invoice. Attributes: ACTIVE (str): 'active' PAID (str): 'paid' EXPIRED (str): 'expired' ''' ACTIVE = 'active' PAID = 'paid' EXPIRED = 'expired' def __str__ ( self ) -> str : return self . value","title":"InvoiceStatus"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.PaidButtonNames","text":"Bases: Enum Name of the button. Attributes: Name Type Description VIEW_ITEM str 'viewItem' OPEN_CHANNEL str 'openChannel' OPEN_BOT str 'openBot' CALLBACK str 'callback' Source code in src/CryptoPayAPI/schemas.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class PaidButtonNames ( Enum ): '''Name of the button. Attributes: VIEW_ITEM (str): 'viewItem' OPEN_CHANNEL (str): 'openChannel' OPEN_BOT (str): 'openBot' CALLBACK (str): 'callback' ''' VIEW_ITEM = 'viewItem' OPEN_CHANNEL = 'openChannel' OPEN_BOT = 'openBot' CALLBACK = 'callback' def __str__ ( self ) -> str : return self . value","title":"PaidButtonNames"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.Transfer","text":"Bases: BaseModel Transfer info. Attributes: Name Type Description transfer_id int Unique ID for this transfer. user_id int Telegram user ID the transfer was sent to. asset Assets Currency code. amount Decimal Amount of the transfer. status Literal ['completed'] Status of the transfer, can be \u201ccompleted\u201d. completed_at datetime Date the transfer was completed in ISO 8601 format. comment Optional [ str ] Optional . Comment for this transfer. Source code in src/CryptoPayAPI/schemas.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class Transfer ( BaseModel ): '''Transfer info. Attributes: transfer_id (int): Unique ID for this transfer. user_id (int): Telegram user ID the transfer was sent to. asset (Assets): Currency code. amount (Decimal): Amount of the transfer. status (Literal['completed']): Status of the transfer, can be \u201ccompleted\u201d. completed_at (datetime): Date the transfer was completed in ISO 8601 format. comment (Optional[str]): *Optional*. Comment for this transfer. ''' transfer_id : int user_id : int asset : Assets amount : Decimal status : Literal [ 'completed' ] completed_at : datetime comment : Optional [ str ]","title":"Transfer"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.Update","text":"Bases: BaseModel Webhook update object. Attributes: Name Type Description update_id int Non-unique update ID. update_type UpdateType Webhook update type. request_date datetime Date the request was sent in ISO 8601 format. payload Invoice Payload contains Invoice object. raw_body Optional [ bytes ] Optional . Raw body of update, for check sign purpose. Source code in src/CryptoPayAPI/schemas.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 class Update ( BaseModel ): '''Webhook update object. Attributes: update_id (int): Non-unique update ID. update_type (UpdateType): Webhook update type. request_date (datetime): Date the request was sent in ISO 8601 format. payload (Invoice): Payload contains `Invoice` object. raw_body (Optional[bytes]): *Optional*. Raw body of update, for check sign purpose. ''' update_id : int update_type : UpdateType request_date : datetime payload : Invoice raw_body : Optional [ bytes ] = None def check_signature ( self , api_key : str , sign : str ) -> bool : '''Check update signature. Args: api_key (str): CryptoPay app API key. sign (str): Update signature. In request headers `crypto-pay-api-signature`. Returns: bool: Is signature verified? ''' log . debug ( f 'Called with args: ( { api_key } , { sign } )' ) secret = sha256 ( api_key . encode ()) . digest () hmac = HMAC ( secret , self . raw_body , digestmod = sha256 ) body_sign = hmac . hexdigest () log . debug ( f 'Calculated hash: { body_sign } ' ) return body_sign == sign","title":"Update"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.Update.check_signature","text":"Check update signature. Parameters: Name Type Description Default api_key str CryptoPay app API key. required sign str Update signature. In request headers crypto-pay-api-signature . required Returns: Name Type Description bool bool Is signature verified? Source code in src/CryptoPayAPI/schemas.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def check_signature ( self , api_key : str , sign : str ) -> bool : '''Check update signature. Args: api_key (str): CryptoPay app API key. sign (str): Update signature. In request headers `crypto-pay-api-signature`. Returns: bool: Is signature verified? ''' log . debug ( f 'Called with args: ( { api_key } , { sign } )' ) secret = sha256 ( api_key . encode ()) . digest () hmac = HMAC ( secret , self . raw_body , digestmod = sha256 ) body_sign = hmac . hexdigest () log . debug ( f 'Calculated hash: { body_sign } ' ) return body_sign == sign","title":"check_signature()"},{"location":"API/CryptoPayAPI/schemas/#src.CryptoPayAPI.schemas.UpdateType","text":"Bases: Enum Webhook update type. Attributes: Name Type Description INVOICE_PAID str 'invoice_paid Source code in src/CryptoPayAPI/schemas.py 76 77 78 79 80 81 82 class UpdateType ( Enum ): '''Webhook update type. Attributes: INVOICE_PAID (str): 'invoice_paid ''' INVOICE_PAID = 'invoice_paid'","title":"UpdateType"},{"location":"examples/get_me/","text":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f # -*- coding: utf-8 -*- # # pyCryptoPayAPI - get_me example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN ) app = await cp . get_me () print ( 'Application: ' , app ) run ( main ())","title":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f"},{"location":"examples/get_me/#_1","text":"# -*- coding: utf-8 -*- # # pyCryptoPayAPI - get_me example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN ) app = await cp . get_me () print ( 'Application: ' , app ) run ( main ())","title":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f"},{"location":"examples/testnet_usage/","text":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438 # -*- coding: utf-8 -*- # # pyCryptoPayAPI - Testnet example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN , testnet = True ) app = await cp . get_me () print ( 'Testnet application: ' , app ) run ( main ())","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438"},{"location":"examples/testnet_usage/#_1","text":"# -*- coding: utf-8 -*- # # pyCryptoPayAPI - Testnet example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN , testnet = True ) app = await cp . get_me () print ( 'Testnet application: ' , app ) run ( main ())","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438"},{"location":"examples/transfer_usage/","text":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u043a\u0440\u0438\u043f\u0442\u043e\u0432\u0430\u043b\u044e\u0442\u044b \u041c\u0435\u0442\u043e\u0434 Transfer \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d! \u041d\u0430\u0447\u0438\u043d\u0430\u044f \u0441 Crypto Pay API v1.1.2, \u043c\u0435\u0442\u043e\u0434 transfer \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0431\u043e\u0442\u043e\u0432, \u043f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u044d\u0442\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430, \u0430\u043a\u0442\u0438\u0432\u0438\u0440\u0443\u0439\u0442\u0435 \u0435\u0433\u043e \u0432 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430\u0445 \u0431\u043e\u0442\u0430. # -*- coding: utf-8 -*- # # pyCryptoPayAPI - Transfer example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay from CryptoPayAPI.schemas import Assets TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN ) if input ( 'You want to donate me 3 USDT? -> ' ) . lower () in [ 'n' , 'no' , '-' ]: print ( 'Okay :(' ) exit () transfer = cp . transfer ( 265300852 , Assets . USDT , 3.0 , 'pCBA226ghd' , comment = 'donate' ) print ( 'Transfer: ' , transfer ) run ( main ())","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u043a\u0440\u0438\u043f\u0442\u043e\u0432\u0430\u043b\u044e\u0442\u044b"},{"location":"examples/transfer_usage/#_1","text":"\u041c\u0435\u0442\u043e\u0434 Transfer \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d! \u041d\u0430\u0447\u0438\u043d\u0430\u044f \u0441 Crypto Pay API v1.1.2, \u043c\u0435\u0442\u043e\u0434 transfer \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0431\u043e\u0442\u043e\u0432, \u043f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u044d\u0442\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430, \u0430\u043a\u0442\u0438\u0432\u0438\u0440\u0443\u0439\u0442\u0435 \u0435\u0433\u043e \u0432 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430\u0445 \u0431\u043e\u0442\u0430. # -*- coding: utf-8 -*- # # pyCryptoPayAPI - Transfer example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay from CryptoPayAPI.schemas import Assets TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN ) if input ( 'You want to donate me 3 USDT? -> ' ) . lower () in [ 'n' , 'no' , '-' ]: print ( 'Okay :(' ) exit () transfer = cp . transfer ( 265300852 , Assets . USDT , 3.0 , 'pCBA226ghd' , comment = 'donate' ) print ( 'Transfer: ' , transfer ) run ( main ())","title":"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u043a\u0440\u0438\u043f\u0442\u043e\u0432\u0430\u043b\u044e\u0442\u044b"},{"location":"examples/webhook_example/","text":"Webhook \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c fastapi \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. # -*- coding: utf-8 -*- # # pyCryptoPayAPI - webhook example usage. # Created by LulzLoL231 at 12/9/22 # from os import environ from uvicorn import run from fastapi import FastAPI , Request from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) app = FastAPI ( openapi_tags = None , # disable docs generating redoc_url = None # disable docs generating ) cp = CryptoPay ( TOKEN ) @app . post ( '/' ) async def process_update ( request : Request ): body = await request . body () headers = dict ( request . headers ) update = await cp . process_webhook_update ( body , headers ) print ( f 'Recieved { update . payload . amount } { update . payload . asset } !' ) return 'ok' if __name__ == '__main__' : run ( app )","title":"\u0412\u0435\u0431\u0445\u0443\u043a"},{"location":"examples/webhook_example/#webhook","text":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c fastapi \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. # -*- coding: utf-8 -*- # # pyCryptoPayAPI - webhook example usage. # Created by LulzLoL231 at 12/9/22 # from os import environ from uvicorn import run from fastapi import FastAPI , Request from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) app = FastAPI ( openapi_tags = None , # disable docs generating redoc_url = None # disable docs generating ) cp = CryptoPay ( TOKEN ) @app . post ( '/' ) async def process_update ( request : Request ): body = await request . body () headers = dict ( request . headers ) update = await cp . process_webhook_update ( body , headers ) print ( f 'Recieved { update . payload . amount } { update . payload . asset } !' ) return 'ok' if __name__ == '__main__' : run ( app )","title":"Webhook"},{"location":"en/get_token/","text":"Get API token To get a CryptoPay API token, you need to contact the bot @CryptoBot . Using the testnet To get a token in the test network, you should contact the bot @CryptoTestnetBot , and follow this instruction. About bot Check bot name Before using the bot, make sure that the information about the bot matches the one below! For main bot @CryptoBot : from test bot @CryptoTestnetBot : Start bot Use the /start command in the bot to exit to the main menu and press the button \ud83c\udfdd\ufe0f Crypto Pay Creating of application Click the Create application button, CryptoBot will automatically create an application for you with a unique name. Getting API token Click the \"API token\" button to see your API token, it consists of an application identifier and a unique string in the format 000000:XXXXXXXXXXXXXXXXXXXXXXXXX Using of token After receiving the token, use it when creating an instance of the class [ CryptoPay ][src.CryptoPayAPI.CryptoPay] like this CryptoPay('000000:XXXXXXXXXXXXXXXXXXXXXXXXX') . Warning Don't forget to set the testnet=True flag if you are using a test bot token, otherwise authorization will fail.","title":"Get API token"},{"location":"en/get_token/#get-api-token","text":"To get a CryptoPay API token, you need to contact the bot @CryptoBot . Using the testnet To get a token in the test network, you should contact the bot @CryptoTestnetBot , and follow this instruction.","title":"Get API token"},{"location":"en/get_token/#about-bot","text":"Check bot name Before using the bot, make sure that the information about the bot matches the one below! For main bot @CryptoBot : from test bot @CryptoTestnetBot :","title":"About bot"},{"location":"en/get_token/#start-bot","text":"Use the /start command in the bot to exit to the main menu and press the button \ud83c\udfdd\ufe0f Crypto Pay","title":"Start bot"},{"location":"en/get_token/#creating-of-application","text":"Click the Create application button, CryptoBot will automatically create an application for you with a unique name.","title":"Creating of application"},{"location":"en/get_token/#getting-api-token","text":"Click the \"API token\" button to see your API token, it consists of an application identifier and a unique string in the format 000000:XXXXXXXXXXXXXXXXXXXXXXXXX","title":"Getting API token"},{"location":"en/get_token/#using-of-token","text":"After receiving the token, use it when creating an instance of the class [ CryptoPay ][src.CryptoPayAPI.CryptoPay] like this CryptoPay('000000:XXXXXXXXXXXXXXXXXXXXXXXXX') . Warning Don't forget to set the testnet=True flag if you are using a test bot token, otherwise authorization will fail.","title":"Using of token"},{"location":"en/","text":"Home Crypto Pay is a payment system based on @CryptoBot , which allows you to accept payments in cryptocurrency using the API. This library help you to work with Crypto Pay via Crypto Pay API in yours Python scripts. Documentation available on English language \u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430 \u043d\u0430 \u0420\u0443\u0441\u0441\u043a\u043e\u043c \u044f\u0437\u044b\u043a\u0435","title":"Home"},{"location":"en/#home","text":"Crypto Pay is a payment system based on @CryptoBot , which allows you to accept payments in cryptocurrency using the API. This library help you to work with Crypto Pay via Crypto Pay API in yours Python scripts. Documentation available on English language \u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430 \u043d\u0430 \u0420\u0443\u0441\u0441\u043a\u043e\u043c \u044f\u0437\u044b\u043a\u0435","title":"Home"},{"location":"en/install/","text":"Install The library can be installed in several ways: With PYPI With pip+git From source pip install pycryptopay-sdk pip install git+https://github.com/LulzLoL231/pyCryptoPayAPI.git pip install . # (1)! Execute in root folder.","title":"Install"},{"location":"en/install/#install","text":"The library can be installed in several ways: With PYPI With pip+git From source pip install pycryptopay-sdk pip install git+https://github.com/LulzLoL231/pyCryptoPayAPI.git pip install . # (1)! Execute in root folder.","title":"Install"},{"location":"en/API/CryptoPayAPI/errors/","text":"Errors","title":"\u0418\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f"},{"location":"en/API/CryptoPayAPI/errors/#errors","text":"","title":"Errors"},{"location":"en/API/CryptoPayAPI/","text":"CryptoPay CryptoPay CryptoPay payment system. Source code in src/CryptoPayAPI/api.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class CryptoPay : '''CryptoPay payment system. ''' def __init__ ( self , api_key : str , testnet : bool = False ) -> None : ''' Args: api_key (str): CryptoPay API token. testnet (bool): Use Testnet? Defaults to False. ''' self . timeout_sec = 5 self . log = logging . getLogger ( 'CryptoPay' ) self . api_key = api_key self . headers = { 'Crypto-Pay-API-Token' : api_key } self . testnet = testnet if testnet : self . endpoint = TESTHOST else : self . endpoint = MAINHOST self . client = AsyncClient ( headers = self . headers , base_url = self . endpoint , timeout = Timeout ( self . timeout_sec ) ) async def _callApi ( self , http_method : str , api_method : str , query : dict = {}) -> dict : '''Makes a api call. Args: http_method (str): HTTP method. Available is \"GET\" and \"POST\". api_method (str): API method. query (dict, optional): Request query in dict. Defaults to {}. Returns: dict: API response as JSON dict viceversa None. ''' self . log . debug ( f 'Called with args ( { http_method } , { api_method } , { query } )' ) if query : params = urllib . parse . urlencode ( query ) else : params = None resp = await self . client . request ( http_method , api_method , params = params ) if resp . is_success : data = resp . json () self . log . debug ( f 'API answer: { data } ' ) if data [ 'ok' ]: return data [ 'result' ] else : raise UnexpectedError ( f '[ { data [ \"error\" ][ \"code\" ] } ] { data [ \"error\" ][ \"name\" ] } ' , data ) else : if resp . status_code == 401 : raise UnauthorizedError ( 'Token not found!' ) elif resp . status_code == 405 : raise MethodNotFoundError ( f 'Method { api_method } not found!' ) elif resp . status_code == 400 : data = resp . json () err = data [ 'error' ][ 'name' ] if err == 'EXPIRES_IN_INVALID' : raise ExpiresInInvalidError ( f 'Expires \" { query [ \"expires_in\" ] } \" is invalid!' , raw_response = data ) elif resp . status_code == 403 : data = resp . json () err = data [ 'error' ][ 'name' ] if err == 'METHOD_DISABLED' : raise MethodDisabledError ( f 'Method \" { api_method } \" is disabled!' , raw_response = data ) data = resp . json () raise UnexpectedError ( f '[ { data [ \"error\" ][ \"code\" ] } ] { data [ \"error\" ][ \"name\" ] } ' , raw_response = data ) async def get_me ( self ) -> schemas . Application : '''Returns basic information about an app. Returns: types.Application: Basic information about an app. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getMe' ) return schemas . Application ( ** result ) async def get_balance ( self ) -> List [ schemas . Balance ]: '''Use this method to get a balance of your app. Returns: List[types.Balance]: Array of assets. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getBalance' ) return [ schemas . Balance ( ** i ) for i in result ] async def get_exchange_rates ( self ) -> List [ schemas . ExchangeRate ]: '''Use this method to get exchange rates of supported currencies. Returns: List[types.ExchangeRate]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getExchangeRates' ) return [ schemas . ExchangeRate ( ** i ) for i in result ] async def get_currencies ( self ) -> List [ schemas . Currency ]: '''Use this method to get a list of supported currencies. Returns: List[types.Currency]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getCurrencies' ) return [ schemas . Currency ( ** i ) for i in result ] async def create_invoice ( self , asset : schemas . Assets , amount : float , description : Optional [ str ] = None , hidden_message : Optional [ str ] = None , paid_btn_name : Optional [ schemas . PaidButtonNames ] = None , paid_btn_url : Optional [ str ] = None , payload : Optional [ str ] = None , allow_comments : bool = True , allow_anonymous : bool = True , expires_in : Optional [ int ] = None ) -> schemas . Invoice : '''Create a new invoice. Args: asset (types.Assets): Currency. amount (float): Amount of invoice in float. description (Optional[str]): Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. hidden_message (Optional[str]): Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. paid_btn_name (Optional[types.PaidButtonNames]): Name of the button that will be shown to a user after the invoice is paid. Defaults to None. paid_btn_url (Optional[str]): Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. payload (Optional[str]): Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. allow_comments (bool): Allow a user to add a comment to the payment. Defaults to True. allow_anonymous (bool): Allow a user to pay the invoice anonymously. Defaults to True. expires_in (Optional[int]): You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. Returns: types.Invoice: Object of the created invoice. ''' self . log . debug ( f 'Called with args ( { asset } , { amount } , { description } , { hidden_message } , { paid_btn_name } , { paid_btn_url } , { payload } , { allow_comments } , { allow_anonymous } , { expires_in } )' ) params = { 'asset' : str ( asset ), 'amount' : amount , 'allow_comments' : allow_comments , 'allow_anonymous' : allow_anonymous } if description : params [ 'description' ] = description elif hidden_message : params [ 'hidden_message' ] = hidden_message elif paid_btn_name : params [ 'paid_btn_name' ] = str ( paid_btn_name ) params [ 'paid_btn_url' ] = paid_btn_url elif payload : params [ 'payload' ] = payload elif expires_in : params [ 'expires_in' ] = expires_in result = await self . _callApi ( 'POST' , 'createInvoice' , params ) return schemas . Invoice ( ** result ) async def get_invoices ( self , asset : Optional [ schemas . Assets ] = None , invoice_ids : Optional [ str ] = None , status : Optional [ schemas . InvoiceStatus ] = None , offset : int = 0 , count : int = 100 ) -> List [ schemas . Invoice ]: '''Use this method to get invoices of your app. Args: asset (Optional[types.Assets]): Currency codes separated by comma. Defaults to all assets. invoice_ids (Optional[str]): Invoice IDs separated by comma. Defaults to None. status (Optional[types.InvoiceStatus]): Status of invoices to be returned. Defaults to all statuses. offset (int): Offset needed to return a specific subset of invoices. Defaults to 0. count (int): Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. Returns: List[types.Invoice]: Array of invoices. ''' self . log . debug ( f 'Called with args ( { asset } , { invoice_ids } , { status } , { offset } , { count } )' ) params : Dict [ str , Union [ str , int ]] = { 'offset' : offset , 'count' : count } if asset : params [ 'asset' ] = str ( asset ) elif invoice_ids : params [ 'invoice_ids' ] = invoice_ids elif status : params [ 'status' ] = str ( status ) result = await self . _callApi ( 'GET' , 'getInvoices' , params ) return [ schemas . Invoice ( ** i ) for i in result [ 'items' ]] async def transfer ( self , user_id : int , asset : schemas . Assets , amount : float , spend_id : str , comment : Optional [ str ] = None , disable_send_notification : Optional [ bool ] = False ) -> schemas . Transfer : '''Use this method to send coins from your app's balance to a user. Args: user_id (int): Telegram user_id. asset (types.Assets): Currency. amount (float): Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use `get_exchange_rates` to convert amounts. spend_id (str): Unique ID to make your request idempotent and ensure that only one of the transfers with the same `spend_id` will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. comment (Optional[str], optional): Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. disable_send_notification (Optional[bool], optional): Pass `True` if the user should not receive a notification about the transfer. Defaults to False. Returns: types.Transfer: Object of completed `transfer`. ''' self . log . debug ( f 'Called with args ( { user_id } , { asset } , { amount } , { spend_id } , { comment } , { disable_send_notification } )' ) params = { 'user_id' : user_id , 'asset' : str ( asset ), 'amount' : amount , 'spend_id' : spend_id } if comment : params [ 'comment' ] = comment elif disable_send_notification : params [ 'disable_send_notification' ] = 'true' result = await self . _callApi ( 'POST' , 'transfer' , params ) return schemas . Transfer ( ** result ) async def process_webhook_update ( self , body : bytes , headers : dict ) -> schemas . Update : '''Process webhook update. Args: body (bytes): Update request body. headers (dict): Update request headers. Returns: types.Update: Webhook update. ''' self . log . debug ( f 'Called with args: ( { body } , { headers } )' ) # type: ignore update = schemas . Update ( ** loads ( body ), raw_body = body ) sign = headers . get ( 'crypto-pay-api-signature' , '' ) if not sign : raise UpdateSignatureError ( 'Not found signature!' , raw_response = update . dict (), raw_headers = headers ) if not update . check_signature ( self . api_key , sign ): raise UpdateSignatureError ( 'Signature validation error!' , raw_response = update . dict (), raw_headers = headers ) return update __init__ ( api_key , testnet = False ) Parameters: Name Type Description Default api_key str CryptoPay API token. required testnet bool Use Testnet? Defaults to False. False Source code in src/CryptoPayAPI/api.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , api_key : str , testnet : bool = False ) -> None : ''' Args: api_key (str): CryptoPay API token. testnet (bool): Use Testnet? Defaults to False. ''' self . timeout_sec = 5 self . log = logging . getLogger ( 'CryptoPay' ) self . api_key = api_key self . headers = { 'Crypto-Pay-API-Token' : api_key } self . testnet = testnet if testnet : self . endpoint = TESTHOST else : self . endpoint = MAINHOST self . client = AsyncClient ( headers = self . headers , base_url = self . endpoint , timeout = Timeout ( self . timeout_sec ) ) create_invoice ( asset , amount , description = None , hidden_message = None , paid_btn_name = None , paid_btn_url = None , payload = None , allow_comments = True , allow_anonymous = True , expires_in = None ) async Create a new invoice. Parameters: Name Type Description Default asset types . Assets Currency. required amount float Amount of invoice in float. required description Optional [ str ] Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. None hidden_message Optional [ str ] Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. None paid_btn_name Optional [ types . PaidButtonNames ] Name of the button that will be shown to a user after the invoice is paid. Defaults to None. None paid_btn_url Optional [ str ] Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. None payload Optional [ str ] Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. None allow_comments bool Allow a user to add a comment to the payment. Defaults to True. True allow_anonymous bool Allow a user to pay the invoice anonymously. Defaults to True. True expires_in Optional [ int ] You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. None Returns: Type Description schemas . Invoice types.Invoice: Object of the created invoice. Source code in src/CryptoPayAPI/api.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 async def create_invoice ( self , asset : schemas . Assets , amount : float , description : Optional [ str ] = None , hidden_message : Optional [ str ] = None , paid_btn_name : Optional [ schemas . PaidButtonNames ] = None , paid_btn_url : Optional [ str ] = None , payload : Optional [ str ] = None , allow_comments : bool = True , allow_anonymous : bool = True , expires_in : Optional [ int ] = None ) -> schemas . Invoice : '''Create a new invoice. Args: asset (types.Assets): Currency. amount (float): Amount of invoice in float. description (Optional[str]): Description for the invoice. User will see this description when they pay the invoice. Up to 1024 characters. Defaults to None. hidden_message (Optional[str]): Text of the message that will be shown to a user after the invoice is paid. Up to 2048 characters. Defaults to None. paid_btn_name (Optional[types.PaidButtonNames]): Name of the button that will be shown to a user after the invoice is paid. Defaults to None. paid_btn_url (Optional[str]): Required if paid_btn_name is used. URL to be opened when the button is pressed. You can set any success link (for example, a link to your bot). Starts with https or http. Defaults to None. payload (Optional[str]): Any data you want to attach to the invoice (for example, user ID, payment ID, ect). Up to 4kb. Defaults to None. allow_comments (bool): Allow a user to add a comment to the payment. Defaults to True. allow_anonymous (bool): Allow a user to pay the invoice anonymously. Defaults to True. expires_in (Optional[int]): You can set a payment time limit for the invoice in seconds. Values between 1-2678400 are accepted. Defaults to None. Returns: types.Invoice: Object of the created invoice. ''' self . log . debug ( f 'Called with args ( { asset } , { amount } , { description } , { hidden_message } , { paid_btn_name } , { paid_btn_url } , { payload } , { allow_comments } , { allow_anonymous } , { expires_in } )' ) params = { 'asset' : str ( asset ), 'amount' : amount , 'allow_comments' : allow_comments , 'allow_anonymous' : allow_anonymous } if description : params [ 'description' ] = description elif hidden_message : params [ 'hidden_message' ] = hidden_message elif paid_btn_name : params [ 'paid_btn_name' ] = str ( paid_btn_name ) params [ 'paid_btn_url' ] = paid_btn_url elif payload : params [ 'payload' ] = payload elif expires_in : params [ 'expires_in' ] = expires_in result = await self . _callApi ( 'POST' , 'createInvoice' , params ) return schemas . Invoice ( ** result ) get_balance () async Use this method to get a balance of your app. Returns: Type Description List [ schemas . Balance ] List[types.Balance]: Array of assets. Source code in src/CryptoPayAPI/api.py 115 116 117 118 119 120 121 122 123 async def get_balance ( self ) -> List [ schemas . Balance ]: '''Use this method to get a balance of your app. Returns: List[types.Balance]: Array of assets. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getBalance' ) return [ schemas . Balance ( ** i ) for i in result ] get_currencies () async Use this method to get a list of supported currencies. Returns: Type Description List [ schemas . Currency ] List[types.Currency]: Array of currencies. Source code in src/CryptoPayAPI/api.py 135 136 137 138 139 140 141 142 143 async def get_currencies ( self ) -> List [ schemas . Currency ]: '''Use this method to get a list of supported currencies. Returns: List[types.Currency]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getCurrencies' ) return [ schemas . Currency ( ** i ) for i in result ] get_exchange_rates () async Use this method to get exchange rates of supported currencies. Returns: Type Description List [ schemas . ExchangeRate ] List[types.ExchangeRate]: Array of currencies. Source code in src/CryptoPayAPI/api.py 125 126 127 128 129 130 131 132 133 async def get_exchange_rates ( self ) -> List [ schemas . ExchangeRate ]: '''Use this method to get exchange rates of supported currencies. Returns: List[types.ExchangeRate]: Array of currencies. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getExchangeRates' ) return [ schemas . ExchangeRate ( ** i ) for i in result ] get_invoices ( asset = None , invoice_ids = None , status = None , offset = 0 , count = 100 ) async Use this method to get invoices of your app. Parameters: Name Type Description Default asset Optional [ types . Assets ] Currency codes separated by comma. Defaults to all assets. None invoice_ids Optional [ str ] Invoice IDs separated by comma. Defaults to None. None status Optional [ types . InvoiceStatus ] Status of invoices to be returned. Defaults to all statuses. None offset int Offset needed to return a specific subset of invoices. Defaults to 0. 0 count int Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. 100 Returns: Type Description List [ schemas . Invoice ] List[types.Invoice]: Array of invoices. Source code in src/CryptoPayAPI/api.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 async def get_invoices ( self , asset : Optional [ schemas . Assets ] = None , invoice_ids : Optional [ str ] = None , status : Optional [ schemas . InvoiceStatus ] = None , offset : int = 0 , count : int = 100 ) -> List [ schemas . Invoice ]: '''Use this method to get invoices of your app. Args: asset (Optional[types.Assets]): Currency codes separated by comma. Defaults to all assets. invoice_ids (Optional[str]): Invoice IDs separated by comma. Defaults to None. status (Optional[types.InvoiceStatus]): Status of invoices to be returned. Defaults to all statuses. offset (int): Offset needed to return a specific subset of invoices. Defaults to 0. count (int): Number of invoices to be returned. Values between 1-1000 are accepted. Defaults to 100. Returns: List[types.Invoice]: Array of invoices. ''' self . log . debug ( f 'Called with args ( { asset } , { invoice_ids } , { status } , { offset } , { count } )' ) params : Dict [ str , Union [ str , int ]] = { 'offset' : offset , 'count' : count } if asset : params [ 'asset' ] = str ( asset ) elif invoice_ids : params [ 'invoice_ids' ] = invoice_ids elif status : params [ 'status' ] = str ( status ) result = await self . _callApi ( 'GET' , 'getInvoices' , params ) return [ schemas . Invoice ( ** i ) for i in result [ 'items' ]] get_me () async Returns basic information about an app. Returns: Type Description schemas . Application types.Application: Basic information about an app. Source code in src/CryptoPayAPI/api.py 105 106 107 108 109 110 111 112 113 async def get_me ( self ) -> schemas . Application : '''Returns basic information about an app. Returns: types.Application: Basic information about an app. ''' self . log . debug ( 'Called!' ) result = await self . _callApi ( 'GET' , 'getMe' ) return schemas . Application ( ** result ) process_webhook_update ( body , headers ) async Process webhook update. Parameters: Name Type Description Default body bytes Update request body. required headers dict Update request headers. required Returns: Type Description schemas . Update types.Update: Webhook update. Source code in src/CryptoPayAPI/api.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 async def process_webhook_update ( self , body : bytes , headers : dict ) -> schemas . Update : '''Process webhook update. Args: body (bytes): Update request body. headers (dict): Update request headers. Returns: types.Update: Webhook update. ''' self . log . debug ( f 'Called with args: ( { body } , { headers } )' ) # type: ignore update = schemas . Update ( ** loads ( body ), raw_body = body ) sign = headers . get ( 'crypto-pay-api-signature' , '' ) if not sign : raise UpdateSignatureError ( 'Not found signature!' , raw_response = update . dict (), raw_headers = headers ) if not update . check_signature ( self . api_key , sign ): raise UpdateSignatureError ( 'Signature validation error!' , raw_response = update . dict (), raw_headers = headers ) return update transfer ( user_id , asset , amount , spend_id , comment = None , disable_send_notification = False ) async Use this method to send coins from your app's balance to a user. Parameters: Name Type Description Default user_id int Telegram user_id. required asset types . Assets Currency. required amount float Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use get_exchange_rates to convert amounts. required spend_id str Unique ID to make your request idempotent and ensure that only one of the transfers with the same spend_id will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. required comment Optional [ str ] Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. None disable_send_notification Optional [ bool ] Pass True if the user should not receive a notification about the transfer. Defaults to False. False Returns: Type Description schemas . Transfer types.Transfer: Object of completed transfer . Source code in src/CryptoPayAPI/api.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 async def transfer ( self , user_id : int , asset : schemas . Assets , amount : float , spend_id : str , comment : Optional [ str ] = None , disable_send_notification : Optional [ bool ] = False ) -> schemas . Transfer : '''Use this method to send coins from your app's balance to a user. Args: user_id (int): Telegram user_id. asset (types.Assets): Currency. amount (float): Amount of the transfer in float. The minimum and maximum amounts for each of the support asset roughly correspond to the limit of 0.01-25000 USD. Use `get_exchange_rates` to convert amounts. spend_id (str): Unique ID to make your request idempotent and ensure that only one of the transfers with the same `spend_id` will be accepted by Crypto Pay API. This parameter is useful when the transfer should be retried (i.e. request timeout, connection reset, 500 HTTP status, etc). It can be some unique withdrawal identifier for example. Up to 64 symbols. comment (Optional[str], optional): Comment for the transfer. Users will see this comment when they receive a notification about the transfer. Up to 1024 symbols. Defaults to None. disable_send_notification (Optional[bool], optional): Pass `True` if the user should not receive a notification about the transfer. Defaults to False. Returns: types.Transfer: Object of completed `transfer`. ''' self . log . debug ( f 'Called with args ( { user_id } , { asset } , { amount } , { spend_id } , { comment } , { disable_send_notification } )' ) params = { 'user_id' : user_id , 'asset' : str ( asset ), 'amount' : amount , 'spend_id' : spend_id } if comment : params [ 'comment' ] = comment elif disable_send_notification : params [ 'disable_send_notification' ] = 'true' result = await self . _callApi ( 'POST' , 'transfer' , params ) return schemas . Transfer ( ** result )","title":"CryptoPay"},{"location":"en/API/CryptoPayAPI/#cryptopay","text":"","title":"CryptoPay"},{"location":"en/API/CryptoPayAPI/schemas/","text":"Schemas Application Bases: BaseModel Application info. Attributes: Name Type Description app_id int Application unique ID. name str Application name. payment_processing_bot_username str Username of Crypto bot. Source code in src/CryptoPayAPI/schemas.py 153 154 155 156 157 158 159 160 161 162 163 class Application ( BaseModel ): '''Application info. Attributes: app_id (int): Application unique ID. name (str): Application name. payment_processing_bot_username (str): Username of Crypto bot. ''' app_id : int name : str payment_processing_bot_username : str Assets Bases: Enum Currency code. Attributes: Name Type Description BTC str Bitcoin TON str Toncoin ETH str Ethereum USDT str Tether USDC str USD Coin BUSD str Binance USD Source code in src/CryptoPayAPI/schemas.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Assets ( Enum ): '''Currency code. Attributes: BTC (str): Bitcoin TON (str): Toncoin ETH (str): Ethereum USDT (str): Tether USDC (str): USD Coin BUSD (str): Binance USD ''' BTC = 'BTC' TON = 'TON' ETH = 'ETH' USDT = 'USDT' USDC = 'USDC' BUSD = 'BUSD' def __str__ ( self ) -> str : return self . value Balance Bases: BaseModel Balance info. Attributes: Name Type Description currency_code str Currency code. available Decimal Available for using. Source code in src/CryptoPayAPI/schemas.py 166 167 168 169 170 171 172 173 174 class Balance ( BaseModel ): '''Balance info. Attributes: currency_code (str): Currency code. available (Decimal): Available for using. ''' currency_code : str available : Decimal Currency Bases: BaseModel Currency info. Attributes: Name Type Description is_blockchain bool Is blockchain asset? is_stablecoin bool Is stable coin? is_fiat bool Is fiat asset? name str Name of currency. code str Code of currency. url Optional [ str ] Optional . URL of currency site. decimals int ? Source code in src/CryptoPayAPI/schemas.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class Currency ( BaseModel ): '''Currency info. Attributes: is_blockchain (bool): Is blockchain asset? is_stablecoin (bool): Is stable coin? is_fiat (bool): Is fiat asset? name (str): Name of currency. code (str): Code of currency. url (Optional[str]): *Optional*. URL of currency site. decimals (int): ? ''' is_blockchain : bool is_stablecoin : bool is_fiat : bool name : str code : str url : Optional [ str ] decimals : int ExchangeRate Bases: BaseModel Exchange rate info. Attributes: Name Type Description is_valid bool Is valid? source str Source asset. target str Target asset. rate Decimal Exchange rate. Source code in src/CryptoPayAPI/schemas.py 177 178 179 180 181 182 183 184 185 186 187 188 189 class ExchangeRate ( BaseModel ): '''Exchange rate info. Attributes: is_valid (bool): Is valid? source (str): Source asset. target (str): Target asset. rate (Decimal): Exchange rate. ''' is_valid : bool source : str target : str rate : Decimal Invoice Bases: BaseModel Invoice info. Attributes: Name Type Description invoice_id int Unique ID for this invoice. status InvoiceStatus Status of the invoice. hash str Hash of the invoice. asset Assets Currency code. amount Decimal Amount of the invoice. pay_url str URL should be presented to the user to pay the invoice. description Optional [ str ] Optional . Description for this invoice. created_at datetime Date the invoice was created in ISO 8601 format. allow_comments bool True , if the user can add comment to the payment. allow_anonymous bool True , if the user can pay the invoice anonymously. expiration_date Optional [ datetime ] Optional . Date the invoice expires in Unix time. paid_at Optional [ datetime ] Optional . Date the invoice was paid in Unix time. paid_anonymously Optional [ bool ] True , if the invoice was paid anonymously. comment Optional [ str ] Optional . Comment to the payment from the user. hidden_message Optional [ str ] Optional . Text of the hidden message for this invoice. payload Optional [ str ] Optional . Previously provided data for this invoice. paid_btn_name Optional [ PaidButtonNames ] Optional . Name of the button. paid_btn_url Optional [ str ] Optional . URL of the button. fee Optional [ Decimal ] Optional . Amount of charged service fees. Returned only if the invoice has paid status. usd_rate Optional [ Decimal ] Optional . Price of the asset in USD. Returned only if the invoice has paid status. Source code in src/CryptoPayAPI/schemas.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class Invoice ( BaseModel ): '''Invoice info. Attributes: invoice_id (int): Unique ID for this invoice. status (InvoiceStatus): Status of the invoice. hash (str): Hash of the invoice. asset (Assets): Currency code. amount (Decimal): Amount of the invoice. pay_url (str): URL should be presented to the user to pay the invoice. description (Optional[str]): *Optional*. Description for this invoice. created_at (datetime): Date the invoice was created in ISO 8601 format. allow_comments (bool): `True`, if the user can add comment to the payment. allow_anonymous (bool): `True`, if the user can pay the invoice anonymously. expiration_date (Optional[datetime]): *Optional*. Date the invoice expires in Unix time. paid_at (Optional[datetime]): *Optional*. Date the invoice was paid in Unix time. paid_anonymously (Optional[bool]): `True`, if the invoice was paid anonymously. comment (Optional[str]): *Optional*. Comment to the payment from the user. hidden_message (Optional[str]): *Optional*. Text of the hidden message for this invoice. payload (Optional[str]): *Optional*. Previously provided data for this invoice. paid_btn_name (Optional[PaidButtonNames]): *Optional*. Name of the button. paid_btn_url (Optional[str]): *Optional*. URL of the button. fee (Optional[Decimal]): *Optional*. Amount of charged service fees. Returned only if the invoice has paid status. usd_rate (Optional[Decimal]): *Optional*. Price of the asset in USD. Returned only if the invoice has paid status. ''' invoice_id : int status : InvoiceStatus hash : str asset : Assets amount : Decimal pay_url : str description : Optional [ str ] created_at : datetime allow_comments : bool allow_anonymous : bool expiration_date : Optional [ datetime ] paid_at : Optional [ datetime ] paid_anonymously : Optional [ bool ] comment : Optional [ str ] hidden_message : Optional [ str ] payload : Optional [ str ] paid_btn_name : Optional [ PaidButtonNames ] paid_btn_url : Optional [ str ] fee : Optional [ Decimal ] usd_rate : Optional [ Decimal ] InvoiceStatus Bases: Enum Status of invoice. Attributes: Name Type Description ACTIVE str 'active' PAID str 'paid' EXPIRED str 'expired' Source code in src/CryptoPayAPI/schemas.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class InvoiceStatus ( Enum ): '''Status of invoice. Attributes: ACTIVE (str): 'active' PAID (str): 'paid' EXPIRED (str): 'expired' ''' ACTIVE = 'active' PAID = 'paid' EXPIRED = 'expired' def __str__ ( self ) -> str : return self . value PaidButtonNames Bases: Enum Name of the button. Attributes: Name Type Description VIEW_ITEM str 'viewItem' OPEN_CHANNEL str 'openChannel' OPEN_BOT str 'openBot' CALLBACK str 'callback' Source code in src/CryptoPayAPI/schemas.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class PaidButtonNames ( Enum ): '''Name of the button. Attributes: VIEW_ITEM (str): 'viewItem' OPEN_CHANNEL (str): 'openChannel' OPEN_BOT (str): 'openBot' CALLBACK (str): 'callback' ''' VIEW_ITEM = 'viewItem' OPEN_CHANNEL = 'openChannel' OPEN_BOT = 'openBot' CALLBACK = 'callback' def __str__ ( self ) -> str : return self . value Transfer Bases: BaseModel Transfer info. Attributes: Name Type Description transfer_id int Unique ID for this transfer. user_id int Telegram user ID the transfer was sent to. asset Assets Currency code. amount Decimal Amount of the transfer. status Literal ['completed'] Status of the transfer, can be \u201ccompleted\u201d. completed_at datetime Date the transfer was completed in ISO 8601 format. comment Optional [ str ] Optional . Comment for this transfer. Source code in src/CryptoPayAPI/schemas.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class Transfer ( BaseModel ): '''Transfer info. Attributes: transfer_id (int): Unique ID for this transfer. user_id (int): Telegram user ID the transfer was sent to. asset (Assets): Currency code. amount (Decimal): Amount of the transfer. status (Literal['completed']): Status of the transfer, can be \u201ccompleted\u201d. completed_at (datetime): Date the transfer was completed in ISO 8601 format. comment (Optional[str]): *Optional*. Comment for this transfer. ''' transfer_id : int user_id : int asset : Assets amount : Decimal status : Literal [ 'completed' ] completed_at : datetime comment : Optional [ str ] Update Bases: BaseModel Webhook update object. Attributes: Name Type Description update_id int Non-unique update ID. update_type UpdateType Webhook update type. request_date datetime Date the request was sent in ISO 8601 format. payload Invoice Payload contains Invoice object. raw_body Optional [ bytes ] Optional . Raw body of update, for check sign purpose. Source code in src/CryptoPayAPI/schemas.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 class Update ( BaseModel ): '''Webhook update object. Attributes: update_id (int): Non-unique update ID. update_type (UpdateType): Webhook update type. request_date (datetime): Date the request was sent in ISO 8601 format. payload (Invoice): Payload contains `Invoice` object. raw_body (Optional[bytes]): *Optional*. Raw body of update, for check sign purpose. ''' update_id : int update_type : UpdateType request_date : datetime payload : Invoice raw_body : Optional [ bytes ] = None def check_signature ( self , api_key : str , sign : str ) -> bool : '''Check update signature. Args: api_key (str): CryptoPay app API key. sign (str): Update signature. In request headers `crypto-pay-api-signature`. Returns: bool: Is signature verified? ''' log . debug ( f 'Called with args: ( { api_key } , { sign } )' ) secret = sha256 ( api_key . encode ()) . digest () hmac = HMAC ( secret , self . raw_body , digestmod = sha256 ) body_sign = hmac . hexdigest () log . debug ( f 'Calculated hash: { body_sign } ' ) return body_sign == sign check_signature ( api_key , sign ) Check update signature. Parameters: Name Type Description Default api_key str CryptoPay app API key. required sign str Update signature. In request headers crypto-pay-api-signature . required Returns: Name Type Description bool bool Is signature verified? Source code in src/CryptoPayAPI/schemas.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def check_signature ( self , api_key : str , sign : str ) -> bool : '''Check update signature. Args: api_key (str): CryptoPay app API key. sign (str): Update signature. In request headers `crypto-pay-api-signature`. Returns: bool: Is signature verified? ''' log . debug ( f 'Called with args: ( { api_key } , { sign } )' ) secret = sha256 ( api_key . encode ()) . digest () hmac = HMAC ( secret , self . raw_body , digestmod = sha256 ) body_sign = hmac . hexdigest () log . debug ( f 'Calculated hash: { body_sign } ' ) return body_sign == sign UpdateType Bases: Enum Webhook update type. Attributes: Name Type Description INVOICE_PAID str 'invoice_paid Source code in src/CryptoPayAPI/schemas.py 76 77 78 79 80 81 82 class UpdateType ( Enum ): '''Webhook update type. Attributes: INVOICE_PAID (str): 'invoice_paid ''' INVOICE_PAID = 'invoice_paid'","title":"Schemas"},{"location":"en/API/CryptoPayAPI/schemas/#schemas","text":"","title":"Schemas"},{"location":"en/examples/get_me/","text":"Get application # -*- coding: utf-8 -*- # # pyCryptoPayAPI - get_me example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN ) app = await cp . get_me () print ( 'Application: ' , app ) run ( main ())","title":"Get application"},{"location":"en/examples/get_me/#get-application","text":"# -*- coding: utf-8 -*- # # pyCryptoPayAPI - get_me example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN ) app = await cp . get_me () print ( 'Application: ' , app ) run ( main ())","title":"Get application"},{"location":"en/examples/testnet_usage/","text":"Use testnet # -*- coding: utf-8 -*- # # pyCryptoPayAPI - Testnet example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN , testnet = True ) app = await cp . get_me () print ( 'Testnet application: ' , app ) run ( main ())","title":"Use testnet"},{"location":"en/examples/testnet_usage/#use-testnet","text":"# -*- coding: utf-8 -*- # # pyCryptoPayAPI - Testnet example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN , testnet = True ) app = await cp . get_me () print ( 'Testnet application: ' , app ) run ( main ())","title":"Use testnet"},{"location":"en/examples/transfer_usage/","text":"Transfer crypto Transfer method maybe disabled! From Crypto Pay API v1.1.2, transfer method disabled by default for new bots, before using this method, activate it in bot settings. # -*- coding: utf-8 -*- # # pyCryptoPayAPI - Transfer example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay from CryptoPayAPI.schemas import Assets TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN ) if input ( 'You want to donate me 3 USDT? -> ' ) . lower () in [ 'n' , 'no' , '-' ]: print ( 'Okay :(' ) exit () transfer = cp . transfer ( 265300852 , Assets . USDT , 3.0 , 'pCBA226ghd' , comment = 'donate' ) print ( 'Transfer: ' , transfer ) run ( main ())","title":"Transfer crypto"},{"location":"en/examples/transfer_usage/#transfer-crypto","text":"Transfer method maybe disabled! From Crypto Pay API v1.1.2, transfer method disabled by default for new bots, before using this method, activate it in bot settings. # -*- coding: utf-8 -*- # # pyCryptoPayAPI - Transfer example usage. # Created by LulzLoL231 at 3/6/22 # from os import environ from asyncio import run from CryptoPayAPI import CryptoPay from CryptoPayAPI.schemas import Assets TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) async def main (): cp = CryptoPay ( TOKEN ) if input ( 'You want to donate me 3 USDT? -> ' ) . lower () in [ 'n' , 'no' , '-' ]: print ( 'Okay :(' ) exit () transfer = cp . transfer ( 265300852 , Assets . USDT , 3.0 , 'pCBA226ghd' , comment = 'donate' ) print ( 'Transfer: ' , transfer ) run ( main ())","title":"Transfer crypto"},{"location":"en/examples/webhook_example/","text":"Webhook Using fastapi as a server. # -*- coding: utf-8 -*- # # pyCryptoPayAPI - webhook example usage. # Created by LulzLoL231 at 12/9/22 # from os import environ from uvicorn import run from fastapi import FastAPI , Request from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) app = FastAPI ( openapi_tags = None , # disable docs generating redoc_url = None # disable docs generating ) cp = CryptoPay ( TOKEN ) @app . post ( '/' ) async def process_update ( request : Request ): body = await request . body () headers = dict ( request . headers ) update = await cp . process_webhook_update ( body , headers ) print ( f 'Recieved { update . payload . amount } { update . payload . asset } !' ) return 'ok' if __name__ == '__main__' : run ( app )","title":"Webhook"},{"location":"en/examples/webhook_example/#webhook","text":"Using fastapi as a server. # -*- coding: utf-8 -*- # # pyCryptoPayAPI - webhook example usage. # Created by LulzLoL231 at 12/9/22 # from os import environ from uvicorn import run from fastapi import FastAPI , Request from CryptoPayAPI import CryptoPay TOKEN = environ . get ( 'CRYPTOPAY_API_TOKEN' , '' ) if not TOKEN : print ( 'Use shell argument \"CRYPTOPAY_API_TOKEN\" for your Crypto Pay API token!' ) exit ( 1 ) app = FastAPI ( openapi_tags = None , # disable docs generating redoc_url = None # disable docs generating ) cp = CryptoPay ( TOKEN ) @app . post ( '/' ) async def process_update ( request : Request ): body = await request . body () headers = dict ( request . headers ) update = await cp . process_webhook_update ( body , headers ) print ( f 'Recieved { update . payload . amount } { update . payload . asset } !' ) return 'ok' if __name__ == '__main__' : run ( app )","title":"Webhook"},{"location":"ru/get_token/","text":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 API \u0442\u043e\u043a\u0435\u043d\u0430 \u0414\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f CryptoPay API \u0442\u043e\u043a\u0435\u043d\u0430, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u044c\u0441\u044f \u043a \u0431\u043e\u0442\u0443 @CryptoBot . \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438 \u0414\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0442\u043e\u043a\u0435\u043d\u0430 \u0432 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0435\u0442\u0438, \u043e\u0431\u0440\u0430\u0449\u0430\u0442\u044c\u0441\u044f \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u043a \u0431\u043e\u0442\u0443 @CryptoTestnetBot , \u0438 \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u044d\u0442\u043e\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438. \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0431\u043e\u0442\u0435 \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0431\u043e\u0442\u0430 \u041f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0431\u043e\u0442\u0430, \u0443\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c \u0447\u0442\u043e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0431\u043e\u0442\u0435 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0439 \u043d\u0438\u0436\u0435! \u0414\u043b\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0433\u043e \u0431\u043e\u0442\u0430 @CryptoBot : \u0414\u043b\u044f \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0431\u043e\u0442\u0430 @CryptoTestnetBot : \u0412\u0445\u043e\u0434 \u0432 \u0431\u043e\u0442\u0430 \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 /start \u0432 \u0431\u043e\u0442\u0435 \u0434\u043b\u044f \u0432\u044b\u0445\u043e\u0434\u0430 \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e \u0438 \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \ud83c\udfdd\ufe0f Crypto Pay \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 , CryptoBot \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u0441\u043e\u0437\u0434\u0430\u0441\u0442 \u0432\u0430\u043c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u043c \u0438\u043c\u0435\u043d\u0435\u043c. \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 API \u0442\u043e\u043a\u0435\u043d\u0430 \u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \"API-\u0442\u043e\u043a\u0435\u043d\" \u0447\u0442\u043e\u0431\u044b \u0443\u0432\u0438\u0434\u0435\u0442\u044c \u0441\u0432\u043e\u0439 API \u0442\u043e\u043a\u0435\u043d, \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u043e\u043d \u0438\u0437 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 000000:XXXXXXXXXXXXXXXXXXXXXXXXX \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u0430 \u041f\u043e\u043b\u0443\u0447\u0438\u0432 \u0442\u043e\u043a\u0435\u043d \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0435\u0433\u043e \u043f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u0438\u043d\u0441\u0442\u0430\u043d\u0441\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 [ CryptoPay ][src.CryptoPayAPI.CryptoPay] \u0432\u043e\u0442 \u0442\u0430\u043a CryptoPay('000000:XXXXXXXXXXXXXXXXXXXXXXXXX') . \u0412\u043d\u0438\u043c\u0430\u043d\u0438\u0435 \u041d\u0435 \u0437\u0430\u0431\u0443\u0434\u044c\u0442\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0444\u043b\u0430\u0433 testnet=True \u0435\u0441\u043b\u0438 \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u0442\u043e\u043a\u0435\u043d \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0431\u043e\u0442\u0430, \u0438\u043d\u0430\u0447\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0435 \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u043e\u0439\u0434\u0435\u043d\u0430.","title":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 API \u0442\u043e\u043a\u0435\u043d\u0430"},{"location":"ru/get_token/#_4","text":"\u041f\u043e\u043b\u0443\u0447\u0438\u0432 \u0442\u043e\u043a\u0435\u043d \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0435\u0433\u043e \u043f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u0438\u043d\u0441\u0442\u0430\u043d\u0441\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 [ CryptoPay ][src.CryptoPayAPI.CryptoPay] \u0432\u043e\u0442 \u0442\u0430\u043a CryptoPay('000000:XXXXXXXXXXXXXXXXXXXXXXXXX') . \u0412\u043d\u0438\u043c\u0430\u043d\u0438\u0435 \u041d\u0435 \u0437\u0430\u0431\u0443\u0434\u044c\u0442\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0444\u043b\u0430\u0433 testnet=True \u0435\u0441\u043b\u0438 \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u0442\u043e\u043a\u0435\u043d \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0431\u043e\u0442\u0430, \u0438\u043d\u0430\u0447\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0435 \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u043e\u0439\u0434\u0435\u043d\u0430.","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u0430"}]}